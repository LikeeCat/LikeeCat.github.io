<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Top 100 - Linked Lists]]></title>
    <url>%2F2024%2F12%2F02%2FTop%20100%20-%20Linked%20Lists%2F</url>
    <content type="text"><![CDATA[2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.` Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807. sul# @param {ListNode} l1 # @param {ListNode} l2 # @return {ListNode} def add_two_numbers(l1, l2) # 获取两个链表代表的数字 nums_1 = get_num(l1) nums_2 = get_num(l2) # 两数相加 ans = nums_1 + nums_2 # 结果反转为链表 result_num = ans.to_s.reverse # 构建链表 dummy = ListNode.new # 哨兵节点，方便管理链表头 current = dummy # 指向当前处理的节点 result_num.chars.each do |val| current.next = ListNode.new(val.to_i) # 创建新节点并链接 current = current.next # 更新当前节点 end dummy.next # 返回链表的头部 end # 辅助函数：将链表转为数字 def get_num(node) nums = &quot;&quot; while node != nil nums = node.val.to_s + nums # 注意拼接顺序 node = node.next # 移动到下一个节点 end nums.to_i end 19. Remove Nth Node From End of List Given the head of a linked list, remove the nth node from the end of the list and return its head. sul# @param {ListNode} head # @param {Integer} n # @return {ListNode} def remove_nth_from_end(head, n) length = get_list_length(head) # 特殊情况：如果删除的是头节点 if length == n return head.next end remove_node(head, length - n + 1) head end def get_list_length(head) length = 0 current = head while current != nil current = current.next length += 1 end length end def remove_node(head, remove_n_th) length = 1 current = head while length &lt; remove_n_th - 1 current = current.next length += 1 end current.next = current.next.next end 21. Merge Two Sorted ListsYou are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] sul# @param {ListNode} list1 # @param {ListNode} list2 # @return {ListNode} def merge_two_lists(list1, list2) list = ListNode.new(val = -1) head = list while !list1.nil? &amp;&amp; !list2.nil? node1 = list1.val node2 = list2.val if node1 &lt; node2 head.next = list1 list1 = list1.next elsif node1 == node2 head.next = list1 list1 = list1.next head = head.next head.next = list2 list2 = list2.next else head.next = list2 list2 = list2.next end head = head.next end head.next = list1.nil? ? list2 : list1 list.next end 23. Merge k Sorted ListsYou are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Example 1: Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] merging them into one sorted list: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Example 2: Input: lists = [] Output: [] Example 3: Input: lists = [[]] Output: [] suldef merge_k_lists(lists) return [] if lists.empty? lists_0 = lists[0] return lists_0 if lists.length == 1 tmp_marge_list = lists_0 for i in 1...lists.length tmp_marge_list = marge_two_list(lists[i], tmp_marge_list) end tmp_marge_list end def marge_two_list(list1, list2) new_list = ListNode.new(val = -1) head = new_list while !list1.nil? &amp;&amp; !list2.nil? node1 = list1 node2 = list2 if node1.val &lt; node2.val head.next = node1 list1 = list1.next elsif node1.val == node2.val head.next = node1 list1 = list1.next head = head.next head.next = node2 list2 = list2.next else head.next = node2 list2 = list2.next end head = head.next end head.next = list1.nil? ? list2 : list1 new_list.next end 24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3] Explanation: suldef swap_pairs(head) dummy = ListNode.new(-1) # 创建虚拟头节点 dummy.next = head pre = dummy # 初始化 pre 指针 while pre.next &amp;&amp; pre.next.next # 交换 pre.next 和 pre.next.next pre.next = swap_pairs_helper(pre.next, pre.next.next) pre = pre.next.next # pre 移动到已交换部分的末尾 end dummy.next end def swap_pairs_helper(pre, current) current_next = current.next # 暂存 current 的下一个节点 current.next = pre # current 指向 pre 完成交换 pre.next = current_next # pre 指向交换后剩余部分 current # 返回 pre（交换后的第二个节点） end 25. Reverse Nodes in k-GroupGiven the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list’s nodes, only nodes themselves may be changed. Example 1: Input: head = [1,2,3,4,5], k = 2Output: [2,1,4,3,5] suldef reverse_k_group(head, k) dummy = ListNode.new(-1) dummy_head = dummy current = head while get_list_deep(current) &gt;= k reversed_head, reversed_tail, current = reverse_list(current, k) dummy_head.next = reversed_head # 将反转的链表接到结果链表 dummy_head = reversed_tail # 更新 dummy_head 为当前反转链表的尾部 end # 连接剩余未处理部分 dummy_head.next = current dummy.next end def get_list_deep(head) deep = 0 while head != nil deep += 1 head = head.next end deep end def reverse_list(head, k) pre = nil current = head tail = head # 记录原链表的头部，反转后会变成尾部 deep = 0 while current != nil &amp;&amp; deep &lt; k next_node = current.next current.next = pre pre = current current = next_node deep += 1 end # 返回反转后的链表头和尾部,以及下一次的头 [pre, tail, current] end 138. Copy List with Random PointerA linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random –&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random –&gt; y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.valrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.Your code will only be given the head of the original linked list. Example 1: Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] suldef copyRandomList(head) get_list_info(head) end def get_list_info(head) dummy_head = Node.new(-1) dummy = dummy_head copy_dummy_head = dummy_head copy_head = head ori_nodes = [] nodes = [] while ! head.nil? node = Node.new(head.val) dummy.next = node nodes &lt;&lt; node ori_nodes &lt;&lt; head dummy = dummy.next head = head.next end new_list = copy_dummy_head.next while !new_list.nil? random_node = ori_nodes.index(copy_head.random) new_list.random = nodes[random_node] unless random_node.nil? new_list = new_list.next copy_head = copy_head.next end dummy_head.next end 141. Linked List CycleGiven head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Example 1: Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). suldef hasCycle(head) fast = head slow = head # 先移动 再判断 while fast &amp;&amp; fast.next fast = fast.next.next slow = slow.next return true if fast == slow end false end Linked List Cycle II Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. suldef detectCycle(head) nodes = {} while head return head if nodes[head] # 如果节点已存在，说明环的起点 nodes[head] = true # 记录当前节点 head = head.next end nil # 如果没有环 end 148. Sort ListGiven the head of a linked list, return the list after sorting it in ascending order. Example 1: Input: head = [4,2,1,3]Output: [1,2,3,4] suldef sort_list(head) return head if head.nil? || head.next.nil? sort_list_helper(head) end def sort_list_helper(head) return head if head.nil? || head.next.nil? fast = head slow = head break_node = nil while fast &amp;&amp; fast.next break_node = slow fast = fast.next.next slow = slow.next end break_node.next = nil pre_sort = sort_list_helper(head) next_sort = sort_list_helper(slow) dummy = ListNode.new(-1) dummy_head = dummy while pre_sort &amp;&amp; next_sort pre_node = pre_sort next_node = next_sort if pre_node.val &lt;= next_node.val dummy_head.next = pre_node dummy_head = dummy_head.next pre_sort = pre_sort.next else dummy_head.next = next_node dummy_head = dummy_head.next next_sort = next_sort.next end end dummy_head.next = pre_sort || next_sort dummy.next end 160. Intersection of Two Linked ListsGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. suldef getIntersectionNode(headA, headB) point_a = headA point_b = headB while point_a != point_b if point_a.nil? point_a = headB else point_a = point_a.next end if point_b.nil? point_b = headA else point_b = point_b.next end end point_a end 206. Reverse Linked ListGiven the head of a singly linked list, reverse the list, and return the reversed list. Example 1: Input: head = [1,2,3,4,5]Output: [5,4,3,2,1] suldef reverse_list(head) pre = nil current = head while current next_node = current.next current.next = pre pre = current current = next_node end pre end 234. Palindrome Linked ListGiven the head of a singly linked list, return true if it is a palindrome or false otherwise. Example 1: Input: head = [1,2,2,1]Output: true suldef is_palindrome(head) return true if head.nil? || head.next.nil? fast = head slow = head # 找到链表的中点 while fast &amp;&amp; fast.next fast = fast.next.next slow = slow.next end # 翻转后续的链表 pre = nil current = slow while current next_node = current.next current.next = pre pre = current current = next_node end # 判断是否是回文 while pre return false if pre.val != head.val pre = pre.next head = head.next end true end 总结 再做链表题的时候注意无论什么时候 原始的链表不能够在操作的时候断开,一旦断开就会丢失数据 了解快慢指针及应用 了解链表的翻转过程 再两个链表进行排序链接时,注意没有排完的部分,一定要在最后补上,不然同样的会丢失数据]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Top 100 - Dynamic Programming]]></title>
    <url>%2F2024%2F11%2F20%2FTop%20100%20-%20Dynamic%20Programming%2F</url>
    <content type="text"><![CDATA[5. Longest Palindromic SubstringGiven a string s, return the longest palindromic substring in s. Example 1: Input: s = “babad”Output: “bab”Explanation: “aba” is also a valid answer.Example 2: Input: s = “cbbd”Output: “bb” suldef longest_palindrome(s) ans = &quot;&quot; # 从最长子串开始检查，逐步减少长度 for len in (s.length).downto(1) # 子串长度从大到小 for i in 0..(s.length - len) # 子串起始位置 cur = s[i, len] # 提取长度为 len 的子串，从 i 开始 if is_pal(cur) return cur # 如果找到回文子串，直接返回 end end end ans end def is_pal(s) left = 0 right = s.length - 1 while left &lt;= right return false if s[left] != s[right] left += 1 right -= 1 end return true end 32. Longest Valid ParenthesesGiven a string containing just the characters &#39;(&#39; and &#39;)&#39;, return the length of the longest valid (well-formed) parentheses substring. Example 1: Input: s = “(()”Output: 2Explanation: The longest valid parentheses substring is “()”.Example 2: Input: s = “)()())”Output: 4Explanation: The longest valid parentheses substring is “()()”.Example 3: Input: s = “”Output: 0 suldef longest_valid_parentheses(s) stack = [-1] vaild = 0 max_length = 0 for i in 0...s.length if s[i] == &quot;(&quot; stack.push(i) else stack.pop if stack.empty? stack.push(i) else max_length = [max_length, i - stack[-1]].max end end end max_length end 70. Climbing StairsYou are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1: Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step sul# @param {Integer} n # @return {Integer} def climb_stairs(n) dp = Array.new(n) dp[0] = 1 dp[1] = 2 for i in 2...n dp[i] = dp[i - 1] + dp[i - 2] end dp[n - 1] end 72. Edit DistanceGiven two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a characterDelete a characterReplace a character Example 1: Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; Output: 3 Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;) rorse -&gt; rose (remove &apos;r&apos;) rose -&gt; ros (remove &apos;e&apos;) sul# @param {String} word1 # @param {String} word2 # @return {Integer} def min_distance(word1, word2) w1 = word1.length w2 = word2.length dp = Array.new(w1 + 1) {Array.new(w2 + 1, -1)} min_distance_helper(word1, word2, w1, w2, dp) end def min_distance_helper(word1, word2, w1, w2,dp) return w2 if w1 == 0 return w1 if w2 == 0 return dp[w1][w2] if dp[w1][w2] &gt;= 0 ans = 0 if word1[w1 - 1] == word2[w2 - 1] ans = min_distance_helper(word1, word2, w1 - 1, w2 - 1, dp) else ans = [min_distance_helper(word1, word2, w1 - 1, w2, dp), min_distance_helper(word1, word2, w1, w2 - 1, dp), min_distance_helper(word1, word2, w1 -1 , w2 - 1, dp), ].min + 1 end dp[w1][w2] = ans return ans end 118. Pascal’s TriangleGiven an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2: Input: numRows = 1 Output: [[1]] sul# @param {Integer} num_rows # @return {Integer[][]} def generate(num_rows) return [[1]] if num_rows == 1 return [[]] if num_rows == 0 dp = Array.new(num_rows) {Array.new(num_rows, 0)} dp[0][0] = 1 dp[0].delete(0) for i in 1...num_rows for j in 0..i if j == 0 or j == i dp[i][j] = 1 else dp[i][j] = dp[i - 1][j - 1] + dp [i - 1][j] end end dp[i].delete(0) end dp end 139. Word BreakGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;] Output: true Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2: Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;] Output: true Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word. Example 3: Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;] Output: false sul# @param {String} s # @param {String[]} word_dict # @return {Boolean} def word_break(s, word_dict) cache = {} word_brack_helper(s, word_dict, cache) end def word_brack_helper(s,word_dict,cache) return true if s == &quot;&quot; return cache[s] if cache.keys.include?(s) for word in word_dict if s.start_with?(word) if word_brack_helper(s[word.length..-1], word_dict, cache) cache[s] = true return true end end end cache[s] = false return false end 152. Maximum Product SubarrayGiven an integer array nums, find a subarray that has the largest product, and return the product.The test cases are generated so that the answer will fit in a 32-bit integer. Example 1: Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: nums = [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. sul# @param {Integer[]} nums # @return {Integer} def max_product(nums) return nums[0] if nums.length == 1 min = nums[0] max = nums[0] max_product = nums[0] for i in 1...nums.length if nums[i] &lt; 0 min, max = max , min end min = [min * nums[i], nums[i]].min max = [max * nums[i], nums[i]].max max_product = [max, max_product].max end max_product end 198. House RobberYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. sul# @param {Integer[]} nums # @return {Integer} def rob(nums) return nums[0] if nums.length == 0 len = nums.length dp = Array.new(len, 0) dp[0] = nums[0] dp[1] = nums[0..1].max for i in 2...len dp[i] = [dp[i-1], dp[i - 2] + nums[i]].max end dp[len - 1] end 279. Perfect SquaresGiven an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. sul# @param {Integer} n # @return {Integer} def num_squares(n) my_queue = [n] visited = Set[n] count = 0 vaild_step_length = Array.new(100){|i| (100 - i) * (100 - i)} while !my_queue.empty? len = my_queue.length for i in 0...len cur = my_queue.shift visited.add(cur) step_lengths = vaild_step_length.filter{|x| x &lt;= cur} puts &quot;#{step_lengths} ++++ #{i}&quot; step_lengths.each do |step_length| remain = cur - step_length if remain == 0 return count += 1 else if !visited.include?(remain) my_queue.push(remain) visited.add(remain) end end end end count += 1 end return -1 end 300. Longest Increasing SubsequenceGiven an integer array nums, return the length of the longest strictly increasing subsequence. Example 1: Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2: Input: nums = [0,1,0,3,2,3] Output: 4 Example 3: Input: nums = [7,7,7,7,7,7,7] Output: 1 suldef length_of_lis(nums) len = nums.length dp = Array.new(len, 1) for i in 1...len for j in 0...i if nums[j] &lt; nums[i] dp[i] = [dp[j] + 1, dp[i]].max end end end dp.max end 322. Coin ChangeYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. Example 1: Input: coins = [1,2,5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1Example 2: Input: coins = [2], amount = 3Output: -1Example 3: Input: coins = [1], amount = 0Output: 0 sul# @param {Integer[]} coins # @param {Integer} amount # @return {Integer} # bfs 算法 def coin_change(coins, amount) return 0 if amount == 0 queue = [amount] visited = Set[amount] count = 0 while !queue.empty? len = queue.length for i in 0...len cur = queue.shift visited.add(cur) for coin in coins remain = cur - coin if remain == 0 return count += 1 end if !visited.include?(remain) &amp;&amp; remain &gt; 0 queue.push(remain) visited.add(remain) end end end count+= 1 end -1 end 416. Partition Equal Subset SumGiven an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise. Example 1: Input: nums = [1,5,11,5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: nums = [1,2,3,5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. sul# @param {Integer[]} nums # @return {Boolean} # 1 5 5 11 # 1 10 10 10 10 20 21 def can_partition(nums) total_sum = nums.sum return false if total_sum % 2 != 0 target = total_sum / 2 len = nums.length dp = Array.new(len + 1) {Array.new(target + 1)} for i in 0..len for j in 0..target if i == 0 &amp;&amp; j == 0 dp[i][j] = true elsif i == 0 dp[i][j] = false elsif j == 0 dp[i][j] = true else # 这里实际上的意思如下 &apos;&apos;&apos; 如果当前的数量已经大于 target ,就只能从 i - 1 里面去找 target 否则代表当前 target 可用 即 从 i - 1 里面去找 target - nums[i - 1] (用了当前元素) 从 i - 1 里面去找 target (不使用当前元素,直接找) &apos;&apos;&apos; if nums[i - 1] &gt; j dp[i][j] = dp[i - 1][j] else dp[i][j] = dp[i - 1][j - nums[i -1]] || dp[i - 1][j] end end end end dp[len][target] end 1143. Longest Common SubsequenceGiven two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”.A common subsequence of two strings is a subsequence that is common to both strings. Example 1: Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3. Example 2: Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot; Output: 3 Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3. Example 3: Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot; Output: 0 Explanation: There is no such common subsequence, so the result is 0. sul# @param {String} text1 # @param {String} text2 # @return {Integer} def longest_common_subsequence(text1, text2) len1 = text1.length len2 = text2.length dp = Array.new(len1 + 1) {Array.new(len2 + 1 , 0)} # 递推的过程实际上就是递归的过程 for i in 1..len1 for j in 1..len2 if text1[i - 1] == text2[j - 1] dp[i][j] = dp[i -1][j-1] + 1 else dp[i][j] = [dp[i-1][j], dp[i][j-1]].max end end end dp[len1][len2] end]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Top 100 - Backtracking]]></title>
    <url>%2F2024%2F11%2F01%2FTop%20100%20-%20Backtracking%2F</url>
    <content type="text"><![CDATA[22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example 1: Input: n = 3 Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;] Example 2: Input: n = 1 Output: [&quot;()&quot;] sul# @param {Integer} n # @return {String[]} def generate_parenthesis(n) ans = [] generate_parenthesis_helper(n,n,ans, &quot;&quot;) ans end def generate_parenthesis_helper(left_remain, right_remain, ans, current_ans) if left_remain == 0 and right_remain == 0 ans &lt;&lt; current_ans end if left_remain &gt; 0 generate_parenthesis_helper(left_remain - 1, right_remain, ans, current_ans + &quot;(&quot;) end if right_remain &gt; left_remain generate_parenthesis_helper(left_remain, right_remain - 1, ans, current_ans + &quot;)&quot;) end end 39. Combination SumGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2: Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Example 3: Input: candidates = [2], target = 1 Output: [] sul# @param {Integer[]} candidates # @param {Integer} target # @return {Integer[][]} def combination_sum(candidates, target) ans = [] combination_sum_helper(candidates, target, ans, [], 0) ans end def combination_sum_helper(candidates, target, ans, current_ans, start) if target == 0 ans &lt;&lt; current_ans return end if target &lt; 0 return end for i in start...candidates.length combination_sum_helper(candidates, target- candidates[i], ans, current_ans + [candidates[i]],i) end end 46. PermutationsGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2: Input: nums = [0,1] Output: [[0,1],[1,0]] Example 3: Input: nums = [1] Output: [[1]] sul# @param {Integer[]} nums # @return {Integer[][]} def permute(nums) ans = [] permute_helper(nums, ans, []) ans end def permute_helper(nums, ans, current_ans) if nums.length == 0 ans &lt;&lt; current_ans return end for i in 0...nums.length permute_helper(nums- [nums[i]], ans, current_ans + [nums[i]]) end end 78. SubsetsGiven an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2: Input: nums = [0] Output: [[],[0]] sul# @param {Integer[]} nums # @return {Integer[][]} def subsets(nums) ans = [] for i in 0..nums.length subsets_helper(nums, i, ans, [], 0) end ans end def subsets_helper(nums, count, ans, current_ans, start) if count == 0 ans &lt;&lt; current_ans return end for i in start...nums.length subsets_helper(nums - [nums[i]], count - 1, ans, current_ans + [nums[i]], i) end end 131. Palindrome PartitioningGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example 1: Input: s = &quot;aab&quot; Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] Example 2: Input: s = &quot;a&quot; Output: [[&quot;a&quot;]] sul # @param {String} s # @return {String[][]} def partition(s) ans = [] partition_helper(s, ans, [], 0) ans end def partition_helper(s, ans, current_ans, start) if start == s.length ans &lt;&lt; current_ans return end for i in start..s.length sub_string = s[start..i] if is_par(sub_string) partition_helper(s, ans, current_ans + [sub_string], i+1) end end end def is_par(s) left = 0 right = s.length - 1 while left &lt;= right return false if s[left] != s[right] left += 1 right -= 1 end return true end]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2024%2F11%2F01%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[912. Sort an ArrayGiven an array of integers nums, sort the array in ascending order and return it. You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible. Example 1: Input: nums = [5,2,3,1]Output: [1,2,3,5]Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).Example 2: Input: nums = [5,1,1,2,0,0]Output: [0,0,1,1,2,5]Explanation: Note that the values of nums are not necessairly unique. sul# 切割数组,自小到大排序 # 归并排序 # 稳定排序 # 时间复杂度 O(n * logn) # @param {Integer[]} nums # @return {Integer[]} def sort_array(nums) return nums if nums.length &lt;= 1 mid = nums.length / 2 left = sort_array(nums[0...mid]) right = sort_array(nums[mid..-1]) sort(left, right) end def sort(left, right) sorted = [] while !left.empty? &amp;&amp; !right.empty? if left.first &lt;= right.first sorted &lt;&lt; left.shift else sorted &lt;&lt; right.shift end end sorted + left + right end # 快速排序 # 非稳定排序 # 时间复杂度 O(n * logn) # @param {Integer[]} nums # @return {Integer[]} def sort_array(nums) return nums if nums.length &lt;= 1 pivot = nums.delete_at(rand(nums.length)) left, right = nums.partition{|x| x &lt;= pivot} sort_array(left) + [pivot] + sort_array(right) end # 冒泡排序 # 稳定排序 # 时间复杂度 O(n ^ 2) def sort(nums) for i in 0...nums.length - 1 for j in 0...nums.length - 1 if nums[j] &gt; nums[j + 1] nums[j], nums[j + 1] = nums[j + 1], nums[j] end end end nums end # 插入排序 # 稳定排序 # 时间复杂度 O(n ^ 2) # @param {Integer[]} nums # @return {Integer[]} def sort_array(nums) (1...nums.length).each do |i| key = nums[i] j = i - 1 while j &gt;=0 &amp;&amp; nums[j] &gt; key nums[j + 1] = nums[j] j -= 1 end nums[j + 1] = key end nums end # 选择排序 # 稳定排序 # 时间复杂度 O(n ^ 2) # @param {Integer[]} nums # @return {Integer[]} def sort_array(nums) n = nums.length for i in 0...(n - 1) min_index = i for j in (i + 1)...n if nums[j] &lt; nums[min_index] min_index = j end end nums[i], nums[min_index] = nums[min_index], nums[i] if min_index != i end nums end]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 动态库和静态库的区别]]></title>
    <url>%2F2022%2F12%2F16%2FiOS%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.简介面试的时候总会被问到静态库和动态库的区别,就在此做一下记录 Static librarya unit of code linked at compile time, which does not change. However, iOS static libraries are not allowed to contain images/assets (only code). You can get around this challenge by using a media bundle though. Dynamic library a unit of code and/or assets linked at runtime that may change. However, only Apple is allowed to create dynamic libraries for iOS . You’re not allowed to create these, as this will get your app rejected. 库的二进制区别是什么我们可以使用 ar 相关的命令进行查看ar : 维护链接编辑器使用的索引库,具体命令行相关可以看这里(https://www.cnblogs.com/machao/p/5288462.html) ➜ ~ ar -t Static Framework.framework/StaticFramework __.SYMDEF SORTED StaticFramework_vers.o StaticTestObject.o ➜ ~ ar -t DynamicFramework.framework/DynamicFramework ar: DynamicFramework.framework/DynamicFramework: Inappropriate file type or format 编译流程区别 对于静态库来讲,它本身的流程在生成.o文件后就停止了,没有经历 Linker 的过程.但是对动态库来讲,它是走完了这一套完整的流程. 静态库静态库实际上是一堆.o的目标文件合集,包含具体的架构信息,在使用的时候,会参与到动态库或者主target的链接过程,是需要一个依附的点的 动态库对于动态库而言则不一样,主 Target 构建的时候遇到动态库就会打一个标记,这个标记再Macho 中长这个样子,这样在 Macho 进行加载的时候,dyld 会通过 @rpath/xxx.framework/xxx 进行动态链接. (这就是动态链接的过程) https://xilankong.github.io/ios%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/2020/07/29/Xcode-build%E8%BF%87%E7%A8%8B%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88.html dyld 如何加载动态库 动静态库加载到内存的区别静态库当你使用静态库时,如果库进行更新,那么你需要更新主 App 才能获取到库的更新. 因为库的代码和 App 代码一起被加载到了应用程序的地址空间中 动态库对于iOS 来讲, 系统的动态库和我们自己的动态库还是有很大的区别的 系统动态库系统动态库： 链接时不复制，程序运行时由系统动态加载到内存，系统只加载一次，多个程序共用，节省内存。 例如下图：抖音和微信的可执行文件加载动态库时，内存中只有一份动态库，不用加载到可执行文件。 我们自己的动态库同一个 APP 里不同的进程可以共用你这个库,假使我们有多个 App,那么多个 App 中都同时存在这个库 总结针对Macos 来讲,但是对于动态库来讲,当库进行更新时,开发人员是无需对应用程序进行构建更新的,Macos中的系统库都是动态库,这样当系统进行升级时,使用到这些库的app,自然而然的就进行了更新,这是一种隐式的升级 虽然在 iOS 中的动态库有很多的限制,但是他还是一个动态库,当我们动态库进行了升级(这里我们假定调用的 api 不变,只是动态库内的实现变了,还需要确保动态库的签名与你的APP签名一致性). 你需要做的重新构建一遍你的动态库,然后替换之前旧版的动态库就好.如果需要上架,还需要再更新一遍App,苹果不允许我们动态下发代码. 关于静态库的吸附性静态库本质是一堆.o 的打包体，首先并不是二进制可执行文件，再者你无法保证主程序把静态库参与链接共同生成二进制可执行文件。 解决方案目前的编译器的解决办法是，首先我无法保证主程序是否包含静态库，再者静态库也无法被dyld加载，那么我直接把你静态库的.o 偷过来，共同组成一个新的二进制。也被称做吸附性。 【如果多个动态库依赖同一静态库？】可执文件（主程序或者动态库）在构建的链接阶段，遇到静态库，吸附进来；遇到动态库，打标记，彼此保持独立。 正因为动态库是保持独立的，可以自定义一个动态库把依赖的静态库吸附进来。对外整体呈现的是动态库特性。其他的组件依赖我们自定义的动态库，由于隔离性的存在，不会出现问题。 关于包体积优化静态库在静态链接阶段，仅把用到的文件link到mach-o中，这一点和动态库区别很大，符合包体积优化需求。在静态链接（ld）阶段，动态库会把整个lib复制进mach-o中，这显然不太符合包体积优化的需求。 关于裁剪如果这个静态库没有被调用,并且代码被编译器优化掉了.那么你就不可以从运行时里面使用这个类,会崩溃如果你确信需要使用(一般来讲一个只有分类的静态库就会遇到问题),你就需要加上 -all_load, -objc, -force_load https://pewpewthespells.com/blog/objc_linker_flags.html -all_loadThe -all_load flag tell the linker that it should link every object file (member) of every static library that is passed to the linker. This is a rather drastic option and can cause your executable binary to dramatically increase in size. This flag should be avoided if at all possible when using many static libraries. -ObjCThe -ObjC flag controls behavior around Objective-C code. This will tell the linker that it should look through all the object files (members) of each static library to find the object files (members) that contain any additional Objective-C runtime data. This allows developers to link object files that only contain Objective-C catagories, or any other Objective-C code that the static analysis cannot resolve as being called directly (such as creating a class using NSClassFromString()). This is the flag that is typically passed when using static libraries that contain Objective-C code. Keep in mind, this flag means that ALL Objective-C code that is passed to the linker will be added to the executable binary regardless of if it gets used or not. -force_loadThe -force_load flag is very similar to the -all_load flag, except that it takes an argument of a path to a static library. When passed to the linker, this flag says that regardless of whatever other flags are passed to the linker, that it should link all of the object files (members) of the specific static library that is specified by the passed argument. This allows for a more controlled behavior of selectively loading all the code from one static library but not having to bloat up the executable binary with unnecessary code from other libraries. 参考Xcode build过程中都做了什么]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Clang Module VS Swift Module]]></title>
    <url>%2F2022%2F12%2F15%2FClang%20Module%20VS%20Swift%20Module%2F</url>
    <content type="text"><![CDATA[ModuleClang Module 是面向 C 语言家族的一种技术，通过 modulemap 文件来组织 .h 文件中的接口信息，中间产物是二进制格式的 pcm 文件。 Swift Module 是面向 Swift 语言的一种技术，通过 Swiftinterface 文件来组织 .swift 文件中的接口信息，中间产物二进制格式的 Swiftmodule 文件。 module 的出现是为了解决 pch 预编译文件因为上下文开放可能会被篡改,如果修改 pch 文件内容后,编译时长大幅劣化的问题. 因此才有了 Clang Module是一个编译单元，或构建产物，对一个软件库的结构化替代封装，供链接器使用. 你可以把它理解为一种对组件的描述，包含了对接口（API）和实现（dylib/a）的描述，同时 Module 的产物是被独立编译出来的，不同的 Module 之间是不会影响的 Module Map这里以 UIKit 的头文件举例,它对框架内的所有文件进行了结构化的描述 framework module UIKit { umbrella header &quot;UIKit.h&quot; module * {export *} link framework &quot;UIKit&quot; } 这个 Module 定义了组件的 Umbrella Header 文件（UIKit.h），需要导出的子 Module（所有），以及需要 Link 的框架名称（UIKit），正是通过这个文件，让编译器了解到 Module 的逻辑结构与头文件结构的关联方式 什么是Umbrella HeaderUmberlla Header 存在于Umbrella Framework 中, Umbrella Framwork 允许subFramework,实际上 Umbrella Framework 是作为一个抽象层出现的,它隐藏了 subFramework 的实现细节,可能会发生变化(在子框架内添加、重命名或删除头文件),通过间接依赖的方式,使用者可以免受这些变化具体内容引用如下:Umbrella Header module 的使用Module 的使用并不麻烦，同样是引用 iAd 这个组件，你只需要这样写即可。 @import iAd; 在使用层面上，这将等价于以前的 #import &lt;iAd/iAd.h&gt; 语句，但是会使用 Clang Module 的特性加载整个 iAd 组件。如果只想引入特定文件（比如 ADBannerView.h），原先的写法是 #import &lt;iAd/ADBannerView.h.h&gt;，现在可以写成： @import iAd.ADBannerView; 通过这种写法会将 iAd 这个组件的 API 导入到我们的应用中，同时这种写法也更符合语义化（semanitc import）。 Module 的编译原理确认开启 module 化以 #import &lt;Foundation/NSString.h&gt; 为例，当我们遇到这个头文件的时候首先会去 Framework 的 Headers 目录下寻找相应的头文件是否存在，然后就会到 Modules 目录下查找 modulemap 文件。 此时，Clang 会去查阅 modulemap 里的内容，看看 NSString 是否为 Foundation 这个 Module 里的一部分。 // Module Map - Foundation.framework/Modules/module.modulemap framework module Foundation [extern_c] [system] { umbrella header &quot;Foundation.h&quot; export * module * { export * } explicit module NSDebug { header &quot;NSDebug.h&quot; export * } } 很显然，这里通过 Umbrella Header，我们是可以在 Foundation.h 中找到 NSString.h 的。 // Foundation.h … #import &lt;Foundation/NSStream.h&gt; #import &lt;Foundation/NSString.h&gt; #import &lt;Foundation/NSTextCheckingResult.h&gt; … 至此，Clang 会判定 NSString.h 是 Foundation 这个 Module 的一部分并进行相应的编译工作，此时也就意味着 #import &lt;Foundation/NSString.h&gt; 会从之前的 textual import 变为 module import Module 的构建细节在构建开始前，Clang 会创建一个完全独立的空间来构建 Module，在这个空间里会包含 Module 涉及的所有文件，除此之外不会带入其他任何文件的信息，而这也是 Module 健壮性好的关键因素之一。 真正能影响到其唯一性的是其构建的参数，也就是 Clang 命令后面的内容，关于这一点后面还会继续展开，这里我们先点到为止 当我们在构建 Foundation 的时候，我们会发现 Foundation 自身要依赖一些组件，这意味着我们也需要构建被依赖组件的 Module。 但很明显的是，我们会发现这些被依赖组件也有自己的依赖关系，在它们的这些依赖关系中，极有可能会存在重复的引用。 此时，Module 的复用机制就体现出来优势了，我们可以复用先前构建出来的 Module，而不必一次次的创建或者引用，例如 Drawin 组件，而保存这些缓存文件的位置就是前面章节里提到的保存 pcm 类型文件的地方。 Clang 会将相应的编译参数进行一次 Hash，将获得的 Hash 值作为 Module 缓存文件夹的名称，这里需要注意的是，不同的参数和值会导致文件夹不同，所以想要尽可能的利用 Module 缓存，就必须保证参数不发生变化。 $ clang -fmodules —DENABLE_FEATURE=1 … ## 生成的目录如下 98XN8P5QH5OQ/ CoreFoundation-2A5I5R2968COJ.pcm Security-1A229VWPAK67R.pcm Foundation-1RDF848B47PF4.pcm $ clang -fmodules —DENABLE_FEATURE=2 … ## 生成的目录如下 1GYDULU5XJRF/ CoreFoundation-2A5I5R2968COJ.pcm Security-1A229VWPAK67R.pcm Foundation-1RDF848B47PF4.pcm 这里我们大概了解了系统组件的 module 构建机制，这也是开启 Enable Modules(C and Objective-C) 的核心工作原理。 Swift ModuleSwift 默认module化,Swift 编译器将 Clang 的大部分功能都包含在里面,这个特性使得我们可以用 Clang Module 的形式来引用 Objc 代码 既然是通过 Module 的形式引入 Objective-C，那么 Framework 的文件结构则是最好的选择，此时编译器寻找方法声明的方式就会有下面三种场景： 对于大部分的 Target 而言，当导入的是一个 Objective-C 类型的 Framework 时，编译器会通过 modulemap 里的 Header 信息寻找方法声明。对于一个既有 Objective-C，又有 Swift 代码的 Framework 而言，编译器会从当前 Framework 的 Umbrella Header 中寻找方法声明，从而解决自身的编译问题，这是因为通常情况下 modulemap 会将 Umbrella Header 作为自身的 Header 值。对于 App 或者 Unit Test 类型的 Target，开发者可以通过为 Target 创建 Briding Header 来导入需要的 Objective-C 头文件，进而找到需要的方法声明。 因此会存在下面的三个套路当 Swift 和 Objective-C 文件同时在一个 App 或者 Unit Test 类型的 Target 中，不同类型文件的 API 寻找机制如下： 当 Swift 和 Objective-C 文件在不同 Target 中，例如不同 Framework 中，不同类型文件的 API 寻找机制如下： 当 Swift 和 Objective-C 文件同时在一个Target 中，例如同一 Framework 中，不同类型文件的 API 寻找机制如下： 由于 Swiftc，也就是 Swift 的编译器，包含了大部分的 Clang 功能，其中就包含了 Clang Module，借由组件内已有的 modulemap 文件，Swift 编译器就可以轻松找到相应的 Objective-C 代码。相比于第二个流程而言，第三个流程中的 modulemap 是组件内部的，而第二个流程中，如果想引用其他组件里的 Objective-C 代码，需要引入其他组件里的 modulemap 文件才可以。所以基于这个考虑，并未在流程 3 中标注 modulemap Swift Module VS Clang ModuleClang Module 是面向 C 语言家族的一种技术，通过 modulemap 文件来组织 .h 文件中的接口信息，中间产物是二进制格式的 pcm 文件。 Swift Module 是面向 Swift 语言的一种技术，通过 Swiftinterface 文件来组织 .swift 文件中的接口信息，中间产物二进制格式的 Swiftmodule 文件。 例如当你的 Swift 组件不想暴露自身的 API 给外部的 Objective-C 代码使用的话，可以将 Build Setting 中 Swift Compiler - General 里的 Install Objective-C Compatiblity Header 参数设置为 NO，其编译参数为 SWIFT_INSTALL_OBJC_HEADER，此时不会生成 -Swift.h 类型的文件，也就意味着外部组件无法以 Objective-C 的方式引用组件内 Swift 代码的 API。 而当你的组件里如果压根就没有 Objective-C 代码的时候，你可以将 Build Setting 中 Packaging 里 Defines Module 参数设置为 NO，它的编译参数为 DEFINES_MODULE, 此时不会生成 .modulemap 类型的文件。 一些自己的理解1.为什么会存在 Clang Module因为pch预编译头文件做的事情其实就是宏替换,Module 不会”复制粘贴”头文件里的内容,也不会让暴露出来的头文件被篡改 #define readonly 0x01 2.为什么会有 Umbrella HeaderUmbrella Header 是在Framework 的概念被引入的，你可以理解为一个模块均存在一个Umbrella Header 用来将那些你想暴露给模块外界调用的头文件包裹在一起。 避免使用者在使用该模块的时候需要手动输入多个Header 的一种解决方案,同是得益于这种方式可以隐藏实现的细节,避免直接的依赖 3.Swift Module 中的 .swiftmodule 和 .swiftInterface 的区别是什么.swiftInterface ,负责声明接口信息, 中间产物二进制格式的 Swiftmodule 文件 4.为什么 Swift 调用 OC 时, OC 需要支持 Clang Module 的形式编译因为Swift的编译器包含了大量的 Clang 功能, Swift 自身编译又是强制使用 module 的形式,因此为了发现 OC 的相关接口,需要使用 module 的形式进行引用(module 的引用形式具有传递性)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试问题汇总]]></title>
    <url>%2F2022%2F10%2F25%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[关于离屏渲染的问题 什么是mask 一个图层可以有一个和它相关的mask(蒙版),mask是一个拥有alpha的位图,当像素和它下面的像素合成之前都会把mask应用到图层的像素上面,当你要设置一个图层的圆角半径的时候,你可以有效的在图层上设置一个mask,最终只有mask中显示出来的部分才会被渲染出来 设置圆角的时候是什么触发了离屏渲染,为什么会触发离屏渲染 是因为mask,layer的圆角将mask应用到一个图层上,core Animation为了应用这个mask,会强制进行屏幕外的渲染.这对GPU产生重负. 离屏渲染为什么消耗性能 离屏渲染合成计算是非常昂贵的,直接将图层合成到桢的缓冲区(在屏幕上),比先创建在屏幕外的缓冲区,然后渲染到纹理中,最后将结果渲染到桢的缓冲区中要廉价的多.因为其中涉及到了两次昂贵的环境切换(转换环境到屏幕外缓冲区,再转换环境到帧缓冲区).为 layer 使用mask或者设置圆角半径(特殊的mask)会造成屏幕外渲染，产生阴影也会如此。 block block使用weakSelf关键字的时候有什么坏处 有可能在你使用block的时候,这个对象就已经被销毁了 使用weakSelf后,如何避免对象已经被销毁 使用strongSelf来保证在block的执行过程中这个变量不被释放 什么是weakSelf weakSelf 是为了block不持有self，避免Retain Circle循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf 什么是strongSelf strongSelf的目的是因为一旦进入block执行，假设不允许self在这个执行过程中释放，就需要加入strongSelf。block执行完后这个strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf static const 什么是extern extern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定 如何使用 //xxx.h extern NSString *const EocStringConstant; //xxx.m NSString *const EocStringConstant = @&quot;VALUE&quot; 为什么使用常量的时候要使用const,而不是宏 1.编译时刻:宏是预编译（编译之前处理），const是编译阶段。 2.编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。 3.宏的好处:宏能定义一些函数，方法。 const不能。 4.宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。 lldb命令 p 和 po 的区别 p -- Evaluate an expression on the current thread. Displays any returned value with LLDB&apos;s default formatting. 使用的是lldb中默认的formatting po – Evaluate an expression on the current thread. Displays any returned value with formatting controlled by the type’s author. 使用的formatter 是lldb中由类型的作者自己控制的(重写对象的description方法) 深拷贝和浅拷贝 nsarray 的 mutablecopy 是深拷贝还是浅拷贝 是深拷贝,它在堆上开辟了一块新的内存空间 深拷贝是什么 不只是拷贝指针,并且拷贝了值 浅拷贝是什么 是拷贝指针,一旦改变,连同拷贝前的也会发生改变 简单讲一下 App 的启动流程review 初始化空间，创建进程 加载解析可执行文件 载入动态连接器，并绑定符号 （指针rebase + bind 符号） 配置用户堆栈（runtime 初始化， 包括 Objc相关的 Class 注册，Category 注册， selector 唯一性检查） 设置线程入口（执行load 方法，用 attribute 修饰的函数调用，创建C ++ 静态全局变量） dyld2 和 dyld3 的区别dyld2 解析 Mach-O 的 Header 和 Load Commands，找到其依赖的库，并递归找到所有依赖的库 加载 Mach-O 文件 进行符号查找 绑定和变基 运行初始化程序 dyld3 本进程外的Mach-O分析器/编译器 预先处理了所有可能影响启动速度的 search path、@rpaths 和环境变量然后分析 Mach-O 的 Header 和依赖，并完成了所有符号查找的工作最后将这些结果创建成了一个启动闭包这是一个普通的 daemon 进程，可以使用通常的测试架构 本进程内执行”lauch closure“的引擎 验证启动闭包的安全性，然后映射到 dylib 之中，再跳转到 main 函数不再需要解析 Mach-O 的 Header 和依赖，也不需要符号查找。 一个启动闭包缓存服务 系统 App 的启动闭包被构建在一个 Shared Cache 中， 我们甚至不需要打开一个单独的文件 对于第三方的 App，我们会在 App 安装或者升级的时候构建这个启动闭包。 在 iOS、tvOS、watchOS中，这一切都是 App 启动之前完成的。在 macOS 上，由于有 Side Load App，进程内引擎会在首次启动的时候启动一个 daemon 进程，之后就可以使用启动闭包启动了。 在其他线程预先处理了 searchpath 、@rpath 和环境变量，然后分析 Macho header 的 依赖，完成所有的符号查找，将这些结果创建成一个启动闭包 验证启动闭包的安全性，然后映射到 dylib 之中，再跳转到 main 函数不再需要解析 Mach-O 的 Header 和依赖，也不需要符号查找。 系统 App 的启动闭包被构建在一个 Shared Cache 中， 我们甚至不需要打开一个单独的文件dyld 3 把很多耗时的查找、计算和 I/O 的事前都预先处理好了，这使得启动速度有了很大的提升 有没有考虑过分布式编译distcc是google的一个开源工具，它不是一个编译器，而是一个负责调度不同设备上的编译器，从而实现分布式编译的工具。 在distcc的流程中，“编译- compile”部分会在其他机器进行，而剩余部分仍然在本机进行。https://github.com/zqxiaojin/distccForXCode distcc 通过网络为每个作业发送完整的预处理源代码，因此志愿者机器所需要的只是它们正在运行distccd守护程序，并且它们安装了适当的编译器。 distcc 本身不是编译器，而是GNU C/C++ 编译器 (gcc)和LLVM 编译器 (clang) 的前端 。（对其他一些编译器有初步支持，但主要关注的是 gcc。）几乎所有 gcc 选项和功能都正常工作。 传统的编译过程可以划分为以下部分： 预处理 - preprocess 编译 - compile 链接 - link 分布式编译的好处可以并行编译，节省编译时间 bazel 和 Jenkins开发人员将Bazel描述为“适合所有人的正确、可重复、快速构建”。Bazel 是一个构建工具，可以快速可靠地构建代码。它用于构建谷歌的大部分软件，因此它被设计用来处理谷歌开发环境中存在的构建问题。另一方面，Jenkins被详细描述为“一个可扩展的开源持续集成服务器”。简而言之，Jenkins CI 是领先的开源持​​续集成服务器。它使用 Java 构建，提供了 300 多个插件来支持构建和测试几乎任何项目。 基于 bazel + 分布式编译 + 大仓库Jenkins + 单机编译 + 多仓库 多线程与 runlooprunloop 包含 model 包含 timer/source/observe 子线程与 runloop子线程的Runloop对象需要我们主动创建并维护,子线程的Runloop对象在第一次获取时就会创建,销毁则是在子线程结束时. 并且创建出来的runLoop对象默认是不开启的,必须手动开启RunLoop. Runloop并不保证线程安全,我们只能在当前线程内部操作当前线程的Runloop对象,而不能在当前线程中去操作其他线程的RunLoop对象. 相关代码如下: NSRunLoop *currentRunLoop = [NSRunloop currentRunloop] //获取当前线程的RunLoop对象,在子线程中调用时如果是第一次获取内部会帮我们创建RunLoop对象 [currentRunLoop run]; [NSRunLooop mainRunLoop] //获取主线程的RunLoop对象 复制代码 runloop 分为很多个mode（request path 请求路径），input sources (来源分为端口通信 ， performselector 线程执行)。 perform selectorInvokes a method of the receiver on the current thread using the default mode after a delay. This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode执行成功时，只会执行一次。如果不成功，就会一直存在runloop中 //取消不传参的方法 [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(delayDo:) object:nil]; //取消传参的方法 [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(delayDo:) object:@&quot;abc&quot;]; UILayerUIView 继承了UIResponder，所以 UIView 可以响应用户的一些操作。而且 UIView 遵循代理 CALayerDelegate 。和 CALayer 有了一点点的联系 CALayer继承于 NSObject ，无法响应用户的操作。view 是 layer 的代理，并且不可改变 clang &amp;&amp; LLVM 1. 预处理，这阶段的工作主要是头文件导入，宏展开/替换，预编译指令处理，以及注释的去除。 2.编译a. 词法分析（Lexical Analysis）：将代码转换成一系列 token，如大中小括号 paren’()’ square’[]’ brace’{}’、标识符 identifier、字符串 string_literal、数字常量 numeric_constant 等等；b. 语法分析（Semantic Analysis）：将 token 流组成抽象语法树 AST；c. 静态分析（Static Analysis）：检查代码错误，例如参数类型是否错误，调用对象方法是否有实现；d. 中间代码生成（Code Generation）：将语法树自顶向下遍历逐步翻译成 LLVM IR。 3.生成汇编代码：LLVM 将 LLVM IR 生成当前平台的汇编代码，期间 LLVM 根据编译设置的优化级别 Optimization Level 做对应的优化（Optimize），例如 Debug 的 -O0 不需要优化，而 Release 的 -Os 是尽可能优化代码效率并减少体积。 Clang是LLVM项目的一个子项目，基于LLVM架构的C/C++/Objective-C编译器前端（Swift的前端是Swift）。 4.生成目标文件汇编器（Assembler）将汇编代码转换为机器代码，它会创建一个目标对象文件，以 .o 结尾。 5.链接链接器（Linker）把若干个目标文件链接在一起，生成可执行文件。 字节码和机器码的区别机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。 字节码是一种中间状态（中间码）的二进制代码（文件）。 需要直译器转译后才能成为机器码。 hash 表的实现内部结构是数组+链表+红黑树，之前有单独说过hashmap的结构 Xcode debug 越狱app 获取到越狱app 编写shell脚本,添加在run script 中 在app打出来复制到设备上之前,通过 shell 命令将.app 替换为越狱的 .app 触摸链路 加入 UIApplication 的事件队列 UIApplication取出队列最前面的事件,通常会下发给 keywindow 主窗口寻找合适的视图来处理触摸事件 (a. 调用 pointInside: withEvent方法判断触摸点是否在当前视图内,如果返回NO,那么hitTest:withEvent返回nil b.如果返回YES,就继续调用子View的hitTest方法,直到有视图返回非空对象时返回改对象(或者遍历完子视图后都没有成功,此时就是自己) 响应的链路subview -&gt; view (controller 的 view) -&gt; controller -&gt; window -&gt; UIApplication -&gt; UIAppDelegate 如何调试没有砸壳的app使用 lldb 进行调试 从手机中将 debugserver 文件复制到 mac 上 更改debugserver的调试权限(默认情况下只能调试自己的app),创建签名的plist文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/ PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt; &lt;true/&gt; &lt;key&gt;run-unsigned-code&lt;/key&gt; &lt;true/&gt; &lt;key&gt;get-task-allow&lt;/key&gt; &lt;true/&gt; &lt;key&gt;task_for_pid-allow&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt; 使用codesign 进行重签名后,并将这个文件复制回手机 执行调试命令 ./debugserver IP:port -a PID|appProjectNameiOS 方法转发 在对应对象的缓存方法列表中查找调用的方法 如果没找到,就在该对象的方法列表中找 如果还没找到,就到父类指针指向的对象中执行1和2 如果一直找到根类都没有找到,就进行消息转发,给自己保留处理找不到这一方法的机会 如果没有进行方法解析,并且也没有找到对应的类和方法,那么就会抛出 doesNotRecognizeSelector 异常 转发方法解析resolveInstanceMethod , 有机会让类添加这个函数的实现forwardingTargetForSelector, 让其他对象执行这个函数forwardInvocation, 更加灵活的处理函数调用 runtime 运行时方法实现通过转发方法解析来实现 ///例如我们有一个people类，people类中没有任何属性和方法， //我们为之添加一个名为sing的方法 - (void)viewDidLoad { [super viewDidLoad]; People *people = [[People alloc] init]; //添加方法 class_addMethod([People class], @selector(sing), class_getMethodImplementation([self class], @selector(peopleSing)), &quot;v@:&quot;); //people调用刚添加的方法 [people performSelector:@selector(sing)]; } - (void)peopleSing { NSLog(@&quot;在唱歌&quot;); } 保证 app 在没有实现方法的情况下不崩溃NSException 是应用级异常，是指 OC 代码运行过程由Objective-C 抛出的异常，基本上是代码运行过程中的逻辑错误。比如往 NSArray 中插入 nil 对象，或者用nil 初始化 NSURL 等。最简单区分一个异常是否 NSException 的方式是看这个异常能否被@trycatch 给捕获。 Mach 异常最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常。 Unix 信号又称BSD 信号，如果开发者没有捕获Mach异常，则会被host层的方法ux_exception()将异常转换为对应的UNIX信号，并通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获signal。 NSException应用级异常，它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，是app自己可控的，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。 void InstallUncaughtExceptionHandler(void) { NSSetUncaughtExceptionHandler( &amp;handleUncaughtException ); } void handleUncaughtException(NSException *exception) { NSString * crashInfo = [NSString stringWithFormat:@&quot;yyyy Exception name：%@\nException reason：%@\nException stack：%@&quot;,[exception name], [exception reason], [exception callStackSymbols]]; NSLog(@&quot;%@&quot;, crashInfo); } NSException-&gt;Mach-&gt;Signal 砸壳的实现原理//获取所有的app 组件 ,加载所有的 动态库 // 获取所有的app组件并导出 function handleMessage(message) { modules = getAllAppModules(); loadAllDynamicLibrary(app_path); modules = getAllAppModules(); for (var i = 0; i &lt; modules.length; i++) { var result = dumpModule(modules[i].path); } } 如何加载所有组件function loadAllDynamicLibrary(app_path) { var defaultManager = ObjC.classes.NSFileManager.defaultManager(); var filenames = defaultManager.contentsOfDirectoryAtPath_error_(app_path, errorPtr); for (var i = 0, l = filenames.count(); i &lt; l; i++) { var file_name = filenames.objectAtIndex_(i); var file_path = app_path.stringByAppendingPathComponent_(file_name); if (file_name.hasSuffix_(&quot;.framework&quot;)) { var bundle = ObjC.classes.NSBundle.bundleWithPath_(file_path); bundle.load() } else if (file_name.hasSuffix_(&quot;.bundle&quot;) || file_name.hasSuffix_(&quot;.momd&quot;) || file_name.hasSuffix_(&quot;.strings&quot;) || file_name.hasSuffix_(&quot;.appex&quot;) || file_name.hasSuffix_(&quot;.app&quot;) || file_name.hasSuffix_(&quot;.lproj&quot;) || file_name.hasSuffix_(&quot;.storyboardc&quot;)) { continue; } else { var isDirPtr = Memory.alloc(Process.pointerSize); Memory.writePointer(isDirPtr,NULL); defaultManager.fileExistsAtPath_isDirectory_(file_path, isDirPtr); if (Memory.readPointer(isDirPtr) == 1) { loadAllDynamicLibrary(file_path); } else { if (file_name.hasSuffix_(&quot;.dylib&quot;)) { var is_loaded = 0; for (var j = 0; j &lt; modules.length; j++) { if (modules[j].path.indexOf(file_name) != -1) { is_loaded = 1; break; } } if (!is_loaded) { dlopen(file_path.UTF8String(), 9) } } } } } } 加载方式framework：获取class并调用load进行加载dylib：判断是否已经被dyld加载过，如果没有就进行加载bundle、momd等类型文件：不处理，直接略过文件夹：进入递归 导出//通过传入组件名,从组件列表中取出对应的组件 var targetmod = null; for (var i = 0; i &lt; modules.length; i++) { if (modules[i].path.indexOf(name) != -1) { targetmod = modules[i]; break; } } //获取组件开始位置,后面再取magic之类的header信息会用到 var modbase = modules[i].base; //创建新旧句柄,用于后面的导入操作 var fmodule = open(newmodpath, O_CREAT | O_RDWR, 0); var foldmodule = open(oldmodpath, O_RDONLY, 0); weak 关键词的实现链接：https://juejin.cn/post/6844904101839372295 iOS是如何实现weak的呢，其实weak的底层是一个hash表，key是所指向对象的指针，value是weak指针的地址数组（因为一个对象可能被多个弱引用指针指向）。 weak objc_initWeak -&gt;对象释放 -&gt; objc_destroyWeak 销毁指针。 storeWeak方法实际上是接收了5个参数，分别是haveOld、haveNew和crashIfDeallocating ，这三个参数都是以模板的方式传入的，是三个bool类型的参数。 分别表示weak指针之前是否指向了一个弱引用，weak指针是否需要指向一个新的引用，若果被弱引用的对象正在析构，此时再弱引用该对象是否应该crash。 该方法维护了oldTable 和newTable分别表示旧的引用弱表和新的弱引用表，它们都是SideTable的hash表。 如果weak指针之前指向了一个弱引用，则会调用weak_unregister_no_lock 方法将旧的weak指针地址移除。 如果weak指针需要指向一个新的引用，则会调用weak_register_no_lock 方法将新的weak指针地址添加到弱引用表中。 调用setWeaklyReferenced_nolock 方法修改weak新引用的对象的bit标志位 1、weak的原理在于底层维护了一张weak_table_t结构的hash表，key是所指对象的地址，value是weak指针的地址数组。2、weak 关键字的作用是弱引用，所引用对象的计数器不会加1，并在引用对象被释放的时候自动被设置为 nil。3、对象释放时，调用clearDeallocating函数根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。4、文章中介绍了SideTable、weak_table_t、weak_entry_t这样三个结构，它们之间的关系如下图所示。 方法调用在修改调 method name时为什么可以调用成功如果没有实现这个方法,那么就会进行消息转发,期间有三次机会处理这个事情 自己处理 resolveInstanceMethod forwardingTargetForSelector, 让其他对象执行这个函数 forwardInvocation, 更加灵活的处理函数调用(自己调用) 如果都没有实现,那么就会发送未识别的异常 TODOlldb调试的原理flutter 的 skia 真的就比 iOS 自身实现的这一套渲染效率高么热更新的实现]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 命令大全]]></title>
    <url>%2F2022%2F07%2F25%2Flinux%20%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux 命令大全磁盘相关1. 查看当前目录下所有文件的大小1du -h --max-depth=1 2. 查看当前文件夹大小1du -sh 3. 查看磁盘利用率1df -h Docker 相关1. 查看当前正在运行的 docker 容器1docker ps 2. 查看所有的 docker 容器1docker ps -a 3. 启动 docker 容器1docker start xxx 4. 停止 docker 容器1docker stop xxx 5.构建指定平台的镜像1docker build --platform linux/amd64,xxxx -t name:tag . 6.保存镜像发送到其他机器1docker save -o tarname.tar name:tag 7. docker 开机重启1docker update --restart=always + CONTAINER ID 8. docker 读取 image1docker load -i error_parser_mail.tar 9. docker 查看 log 日志1docker logs --tail 2000 xxx Linux 定时器1. 列出目前定时器的时程表1crontab -l : 列出目前的时程表 2. 重启定时器1/etc/init.d/cron restart VNC 相关1. 重启 vnc 服务1vncserver restart 2.带有端口号的重启1vncserver :1 机器相关1. centos 重启机器1shutdown -r now 2. 查看系统内核1uname -a 3. 查看系统信息1cat /proc/version 4. 查看 centos 版本1cat /etc/redhat-release 5.查看 cpu 信息1cat /proc/cpuinfo 6.查看内存占用率1top 按 c 进入交互模式 name dec P 按CPU使用排序 N 以PID的大小排序 R 对排序进行反转 7.java jvm 启动参数修改1JAVA_OPTS=&quot;-server -Xms1024m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=512m&quot;]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20. Valid Parentheses]]></title>
    <url>%2F2020%2F12%2F13%2FValid%20Parentheses%2F</url>
    <content type="text"><![CDATA[题目 一些思考 从题目给出的意思来看的话,这道题就是用Close brackets 来匹配 Open brackets,那么这个数组的数目必须是偶数个,否则肯定无法匹配 如果刚开始就是Close bracket那么也无法匹配 Open brackets 需要优先去匹配离他最近的 Close bracket,且中间不能有其他未匹配完的符号 思路 代码class Solution { //存放未匹配到Close brackets 的数组 var element:[Character] = [] //匹配字符串用到的字典 let validDic:[String:Character] = [&quot;[&quot;:&quot;]&quot;,&quot;{&quot;:&quot;}&quot;,&quot;(&quot;:&quot;)&quot;] func isValid(_ s: String) -&gt; Bool { for i in s{ //如果是Open bracket,就放入brackets的数组 if i == &quot;[&quot; || i == &quot;{&quot; || i == &quot;(&quot;{ self.element.append(i) } else{ //如果Stack为空,那么就不匹配 if self.element.isEmpty { return false } else{ //找到栈顶的元素,与当前的i进行对比 let lastElement = String(self.element.last!) if validDic[String.init(lastElement)] == i { self.element.removeLast() } else{ return false } } } } //如果栈中不存在任何的元素,则证明匹配成功 return self.element.isEmpty } }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSDictionary 使用中的一些问题]]></title>
    <url>%2F2020%2F07%2F29%2FNSDictionary%20%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[NSDictionary 使用中的一些问题1. dictionaryWithObjectsAndKeysNSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;12&quot;,@&quot;key&quot;,&quot;11&quot;,@&quot;age&quot;,nil]; NSLog(@&quot;dic is %@&quot;,dic); 我们在使用dictionaryWithObjectsAndKeys或者一些其他字面量去创建OC对象的时候，参数应该是Objective-C字符串，不是C语言的字符串 ##2. 关于NSDictionary 转 JSON字符串的坑我们经常能在网上搜到下面的内容 -(NSString*)convertAlfredaJsonString:(NSDictionary *)dic{ NSString *jsonString = nil; NSError *error; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error]; if (!jsonData) { return @&quot;&quot;; } else { jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; } return jsonString; } ##坑在你使用上面代码的时候，你生成的 json字符串中会带有&quot;\n&quot;的换行符，因为这个换行符，因为web、后端可能对换行符进行了一些处理，直接这么传过去，可能会出现问题 正确的做法NSMutableString *occultStr = [NSMutableString stringWithString:jsonString]; NSRange range = {0,jsonString.length}; //去掉字符串中的空格 [occultStr replaceOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot; options:NSLiteralSearch range:range]; NSRange range2 = {0,occultStr.length}; [occultStr replaceOccurrencesOfString:@&quot;\n&quot; withString:@&quot;&quot; options:NSLiteralSearch range:range2]; 在生成 json字符串后，将其中的&quot;\n&quot;、&quot; &quot;空格去掉，然后再传给后端]]></content>
      <categories>
        <category>tip</category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中framework的相关命令]]></title>
    <url>%2F2020%2F07%2F25%2FiOS%E4%B8%ADframework%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[#查看framework支持的处理器架构 进入framework的目录下面 cd /xxx/xxx.framework 输入命令 lipo -info xxxframework //这里的xxxframwork 是指framework中的二进制 查看framework是静态库还是动态库 输入命令 file xxx/xxxframework //这里的xxxframework 是指framework中的二进制 #查看framework 中是否包含UIWebView 进入项目目录下面 cd /xxx/xxx.framework 输入命令 find . -type f | grep -e &quot;.a&quot; -e &quot;.framework&quot; | xargs grep -s UIWebView #xxx.framework contains unsupported architectures ‘[x86_64, i386]’ 这个framework中包含x86_64, i386架构,这个在iOS中是不允许的 在app对应的target -&gt; build phases -&gt; new Run Script Phase 输入命令 # Without further ado, here’s the script. Add a Run Script step to your build steps, put it after your step to embed frameworks, set it to use /bin/sh and enter the following script: APP_PATH=&quot;${TARGET_BUILD_DIR}/${WRAPPER_NAME}&quot; # This script loops through the frameworks embedded in the application and # removes unused architectures. find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK do FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable) FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot; echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot; EXTRACTED_ARCHS=() for ARCH in $ARCHS do echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot; lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot; EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;) done echo &quot;Merging extracted architectures: ${ARCHS}&quot; lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;${EXTRACTED_ARCHS[@]}&quot; rm &quot;${EXTRACTED_ARCHS[@]}&quot; echo &quot;Replacing original executable with thinned version&quot; rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; done]]></content>
      <categories>
        <category>frame</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github下载代码太慢]]></title>
    <url>%2F2020%2F06%2F23%2Fgithub%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2%2F</url>
    <content type="text"><![CDATA[原因我们总是需要在github去下载一些代码,但是因为一些原因,下载的速度忽快忽慢,而一些第三方的网站号称可以代下载,但是也是会很慢,或者直接就下载不下来,这个时候我们就需要用到码云来帮助我们下载.接下来我们以CocoaPods为例 1.获取github的仓库地址 2.登录码云并选择创建仓库 3.导入仓库输入对应的仓库地址,完成后选择导入 4.完成导入导入完成后你就可以在你的码云仓库中找到对应的仓库,这个时候再下载就会很快了]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 加载txt文件]]></title>
    <url>%2F2019%2F11%2F17%2F%20Flutter%20%E5%8A%A0%E8%BD%BDtxt%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Flutter 之加载txt文件我想要加载工程中的txt文件,网上搜了一圈,没有找到相关的内容,在此做一下脱坑的记录 1.在工程下新建txt文件 2.在pubspec.yaml中引用 assets: -data/agreeText.txt 3.在dart文件中使用引入头文件,并复制这个方法import ‘package:flutter/services.dart’ show rootBundle; Future loadAsset() async { var a = await rootBundle.loadString(‘data/agreeText.txt’); return a;} 在widget中使用因为是异步函数,所以需要结合setseate来使用 var _result = &quot;&quot;; dynamic result; void loadAssests() async { result = await loadAsset(); print(result); setState(() { _result = result.toString(); }); } @override void initState() { loadAssests(); } @override Widget build(BuildContext context) { return new MaterialApp( title: &apos;Welcome to Flutter&apos;, home: new Scaffold( appBar: new AppBar( title: new Text(&apos;Welcome to Flutter&apos;), ), body: new Center( child: new Text(_result), ), ), ); }]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSArray之深浅拷贝]]></title>
    <url>%2F2019%2F06%2F11%2FNSArray%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[1. 自定义对象 假设我有一个Student类 @interface Student()&lt;NSCopying,NSMutableCopying&gt; @property (nonatomic,copy)NSString *name; @property (nonatomic,assign)NSInteger age; @end 生成两个Student对象 Student *stu = [[Student alloc]initWithName:@&quot;a&quot; age:1]; Student *stu1 = [[Student alloc]initWithName:@&quot;b&quot; age:2]; 用NSArray去把这两个对象加进数组,分别对数组进行copy 和 mutableCopy NSArray *arr = [NSArray arrayWithObjects:stu,stu1, nil]; NSArray *arrCopy = [arr copy] ; NSMutableArray *arrMuCopy = [arr mutableCopy]; 在arrMuCopy之后打断点查看结果 po arr &lt;__NSArrayI 0x102900290&gt;( &lt;Student: 0x100646bc0&gt;, &lt;Student: 0x100647300&gt; ) po arrCopy &lt;__NSArrayI 0x102900290&gt;( &lt;Student: 0x100646bc0&gt;, &lt;Student: 0x100647300&gt; ) po arrMuCopy &lt;__NSArrayM 0x1029056f0&gt;( &lt;Student: 0x100646bc0&gt;, &lt;Student: 0x100647300&gt; ) 从结果上来说,copy只是复制了一个指针,arr 和 arrCopy 在堆上的对象是同一个.而arrMuCopy则是创建了新的内存地址,即创建了一个新的NSMutableArray的对象,但是array中包含的自定义对象没有复制. 重写Student的description方法 -(NSString *)description{ return [NSString stringWithFormat:@&quot;name:%@\n age :%d&quot;,self.name,self.age]; } 在copy 和 mutableCopy 结束后打断点 NSArray *arr = [NSArray arrayWithObjects:stu,stu1, nil]; NSArray *arrCopy = [arr copy] ; NSMutableArray *arrMuCopy = [arr mutableCopy]; [stu changeName:@&quot;ccc&quot;]; po arr &lt;__NSArrayI 0x1029002c0&gt;( name:ccc age :1, name:b age :2 ) po arrCopy &lt;__NSArrayI 0x1029002c0&gt;( name:ccc age :1, name:b age :2 ) po arrMuCopy &lt;__NSArrayM 0x102909590&gt;( name:ccc age :1, name:b age :2 ) 结果也论证了这一点,mutableCopy后并没有将array中的对象进行复制 NSString 用NSArray去把这两个对象加进数组,分别对数组进行copy 和 mutableCopy NSArray *arr = [NSArray arrayWithObjects:@&quot;aaa&quot;,@&quot;bbb&quot;, nil]; NSArray *arrCopy = [arr copy] ; NSMutableArray *arrMuCopy = [arr mutableCopy]; 在copy 和 mutableCopy 结束后打断点 po arr &lt;__NSArrayI 0x100504700&gt;( aaa, bbb ) po arrCopy &lt;__NSArrayI 0x100504700&gt;( aaa, bbb ) po arrMuCopy &lt;__NSArrayM 0x100503290&gt;( aaa, bbb ) p arr[0] (__NSCFConstantString *) $4 = 0x00000001000020d0 @&quot;aaa&quot; p arrCopy[0] (__NSCFConstantString *) $7 = 0x00000001000020d0 @&quot;aaa&quot; p arrMuCopy[0] (__NSCFConstantString *) $6 = 0x00000001000020d0 @&quot;aaa&quot; 结果也论证了这一点,mutableCopy后并没有将array中的对象进行复制]]></content>
      <categories>
        <category>NSArray</category>
      </categories>
      <tags>
        <tag>NSArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode快捷键]]></title>
    <url>%2F2019%2F05%2F30%2FXcode%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[编辑的快捷键 快捷键名称 作用 command + ↑ 到达文件头部 command + ↓ 到达文件尾部 command + [ 向左移动代码 command + ] 向右移动代码 option + command + [ 向上移动代码 option + ↑ 向上移动一行代码 option + ↓ 向下移动一行代码 option + command + ] 向下移动代码 command + / 快速注释或者取消注释 Ctrl + A 移动光标到本行行首 Ctrl + E 移动光标到本行行尾 option + → 移动光标到下一个单词 option + ← 移动光标到上一个单词 视图快捷键 快捷键名称 作用 shift + command + y 隐藏/打开控制台 Ctrl + command + ↑↓ 快速切换.h和.m文件 Ctrl + command + → ← 打开下一个/上一个文件 搜索快捷键 快捷键名称 作用 command + f 在当前文件搜索 shift + command + f 打开全局搜索 command + g 跳到下一个搜索结果 shift +command + g 跳到上一个搜索结果 shift +command + o 快速打开一个文件 编译快捷键 快捷键名称 作用 command + r 运行 command + b 编译 shift + command + k 清除工程]]></content>
      <categories>
        <category>tip</category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中文排序]]></title>
    <url>%2F2019%2F05%2F29%2FiOS%E4%B8%AD%E6%96%87%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序方法localizedCompare(_:)Compares the string and a given string using a localized comparison. 在NSString 的 API 中有这个方法,假设你的手机使用的是中文,就可以根据中文排序 NSSortDescriptorAn immutable description of how to order a collection of objects based on a property common to all the objects. 可以根据集合中的对象的某一个属性对这个集合进行排序 initWithKey:ascending:selector:- (instancetype)initWithKey:(NSString *)key ascending:(BOOL)ascending selector:(SEL)selector; 根据给出的key 升序还是降序 还有使用selector来初始化 使用场景定义对象@interface person : NSObject @property (nonatomic,strong)NSString *name; @property (nonatomic,strong)NSString *phone; @end 定义对象的集合person *p = [[person alloc]initWithName:@&quot;小小&quot; phone:@&quot;13322223333&quot;]; person *p1 = [[person alloc]initWithName:@&quot;小二&quot; phone:@&quot;13322223333&quot;]; person *p2 = [[person alloc]initWithName:@&quot;校小&quot; phone:@&quot;13322223333&quot;]; NSMutableArray *arr = [NSMutableArray arrayWithArray:@[p,p1,p2]]; 定义排序方法NSArray *sortDescriptors = [NSArray arrayWithObject:[NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES selector:@selector(localizedCompare:)]]; 进行排序[arr sortUsingDescriptors:sortDescriptors];]]></content>
      <categories>
        <category>tip</category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC中函数的一些小技巧]]></title>
    <url>%2F2019%2F04%2F16%2FOC%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简介最近在做一个复杂的界面，涉及到 UINavigationController 、UITabBarController、UIViewController、之间的函数调用，需要把原先在UIViewController中的功能转移到UITabBarController 或者 UINavigationController中，这就导致了界面产生冲突，我已经在UIViewController中完成了这个方法，怎么在UINavigationController中调用 关于objc_msgSend在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说叫做传递消息。消息有名称 (name) 或选择子 (selector) ,可以接受参数，并且还有可能有返回值。 IMP类的方法列表会把selector的名称的映射到相对应的方法上，使得“动态消息派发系统”能够据此找到相应的方法。这些方法均以函数指针的形式来表示，这种指针就是IMP id (*IMP) = (id,SEL,...) selector(SEL)的生成SEL的生成分为三种情况1.无参 SEL selector = NSSelectorFromString(@&quot;log&quot;); 2.有参数 SEL selector = NSSelectorFromString(@&quot;logWithAll:type:&quot;); IMP的生成IMP imp1 = [self methodForSelector:selector]; 方法的执行- (NSString *)logWithAll:(NSString *)name type:(NSString *)type{ NSLog(@&quot;name is %@ type is %@&quot;,name,type); return @&quot;aaa&quot;; } if ([self respondsToSelector:selector]) { NSString* (*func)(id,SEL,NSString*,NSString*) = (void *)imp1; NSString *result = func(self,selector,@&quot;哈哈&quot;,@&quot;hehe&quot;); NSLog(@&quot;result is %@&quot;,result); } ##结果结构大概就是这样的 NSString* (*func)(id,SEL,NSString*,NSString*) = (void *)imp1; 返回值 parmar1 parmar2 IMP 调用 NSString *result = func(self,selector,@&quot;哈哈&quot;,@&quot;hehe&quot;); 输出结果]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把博客从简书搬出来]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%8A%8A%E5%8D%9A%E5%AE%A2%E4%BB%8E%E7%AE%80%E4%B9%A6%E6%90%AC%E5%87%BA%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[起忽然觉得大多数的写作的地方都太浮躁了，自己想找个安静的角落，写一写关于技术、生活、旅游方面的姑且认为是文章啦，于是就有了想自己做一个静态网站的想法。 接下来花了一周的时间想了很久，最终还是在 GitHub 上安家了，离开自己的舒服区，跑来折腾前端的我也是有够拼的。接下来就慢慢的写，让自己能够得到一些沉淀吧。折腾了一天的我，突然发现天也已经暗了下来，不过总算是完成了一大半的工程。 终这应该就是我的桃花源吧。晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中 CSV格式文件读写]]></title>
    <url>%2F2019%2F03%2F16%2FiOS-%E4%B8%AD-CSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[CSV逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本)。（:来自百度百科） CSV其实就是一个纯文本,那么对应到 Objective-C 中，他就是一个NSString,对应到 Swift 中就是一个String 举个🌰 sj_mino1001.jpg,715282,4FB55FE8sj_mino1002.jpg,471289,93203C5Csj_mino1003.jpg,451929,C4E80467这个就是一个简单的CSV文件,每个值之间用,分割,在一行数据结束的时候才换行。 CSV读取假设我们的项目中有一个 csv 文件，叫做1 1.获取文件路径 NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;1&quot; ofType:@&quot;csv&quot;]; 2.将此文件转码为一个字符串 NSError *error = nil; //GBK编码 NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:0x80000632 error:&amp;error]; //UTF8编码 NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error]; 3.切割字符串，可以拿到每一行的数据 //取出每一行的数据 NSArray *_allLinedStrings = [fileContents componentsSeparatedByString:@&quot;\r\n&quot;]; 4.如果有表头可以对表头进行处理，即对第一行数据进行处理 __block NSInteger nameRow = 0; __block NSInteger phoneRow = 0; NSArray *firstLine = [_allLinedStrings[0] componentsSeparatedByString:@&quot;,&quot;]; [firstLine enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { NSString *line = obj; if ([line isEqualToString:@&quot;客户名称&quot;]){ nameRow = idx; } else if ([line isEqualToString:@&quot;手机号&quot;]){ phoneRow = idx; } }]; 5.对数据进行处理 [_allLinedStrings enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if (idx == 0) { } else{ NSString *str = obj; NSArray *array = [str componentsSeparatedByString:@&quot;,&quot;]; //获取到某一行的数据，切割这个字符串就可以拿到这一行的值，然后在进行下一步的处理 } }]; CSV文件的写入假设我们有一个 likee.csv 需要放在Documents目录下 1.创建写入路径 NSString *fileNameStr = @&quot;likee.Csv&quot;; NSString *DocPath = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:fileNameStr]; 2.够造需要写入的数据 NSString *str = @&quot;11111,22222,33333,44444\n&quot;; NSMutableString *csvString = [NSMutableString string]; for (int i = 0; i&lt; 400; i ++) { [csvString appendString:str]; }; 3.够造为NSData，并使用NSData进行文件的写入。 NSData *data = [csvString dataUsingEncoding:NSUTF8StringEncoding]; [data writeToFile:DocPath atomically:YES]; 编码格式的坑在 mac 下文本的默认编码格式使用的是UTF-8，在 windows 的 Excel 上，对中文的处理是GBK,所以可能会造成乱码的问题。如果读取文件是无法读出内容，就和使用的编码格式有关。所以建议先使用UTF-8进行解码，如果无法显示内容，再用GBK进行解码 //UTF8编码 NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error]; if(!fileContents){ //GBK编码 fileContents = [NSString stringWithContentsOfFile:path encoding:0x80000632 error:&amp;error]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSArray 之 SEL 的保存]]></title>
    <url>%2F2019%2F02%2F27%2FNSArray%20%E4%B9%8B%20SEL%20%E7%9A%84%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[简介最近在初始化类的时候，会有很多没有返回值的初始化方法需要调用，每次都需要再写一遍，所以想把函数装进 NSArray 中可以自动调用。结果查了一下真的可以，所以做个笔记记一下 - (void)viewDidLoad { [super viewDidLoad]; NSString* A = NSStringFromSelector(@selector(loadA)); NSString* B = NSStringFromSelector(@selector(loadB)); NSString* C = NSStringFromSelector(@selector(loadC)); NSArray *arr = @[A,B,C]; [arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { NSString *selector = obj; if (!self) { return; } SEL performSelector = NSSelectorFromString(selector); if ([self respondsToSelector:performSelector]){ [self performSelector:performSelector]; } }]; } - (void)loadA{ NSLog(@&quot;call load A +++++++&quot;); } - (void)loadB{ NSLog(@&quot;call load B ++++++++&quot;); } - (void)loadC{ NSLog(@&quot;call load C +++++&quot;); } 然后就写了一个小 demo,写完后报了警告，查过爆栈热门 iOS 问题后，解决了这个问题。 NSString* A = NSStringFromSelector(@selector(loadA)); NSString* B = NSStringFromSelector(@selector(loadB)); NSString* C = NSStringFromSelector(@selector(loadC)); NSArray *arr = @[A,B,C]; [arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { NSString *selector = obj; if (!self) { return; } SEL performSelector = NSSelectorFromString(selector); IMP imp = [self methodForSelector:performSelector]; void (*func)(id, SEL) = (void *)imp; func(self, performSelector); }];]]></content>
      <categories>
        <category>NSArray</category>
      </categories>
      <tags>
        <tag>NSArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView reloadData 滑不到底部]]></title>
    <url>%2F2019%2F02%2F18%2FUITableView%20reloadData%20%E6%BB%91%E4%B8%8D%E5%88%B0%E5%BA%95%E9%83%A8%2F</url>
    <content type="text"><![CDATA[简介最近有个需求，在 tableView reloadData结束后，需要滑动到底部，可是总是不能准确的滚动到底部。自然而言的就想到了三个方法，查看了一下有关的文档 layoutSubviews setNeedsLayout layoutIfNeeded layoutSubviewsLays out subviews. DiscussionSubclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly. You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method. 在子类中，如果你需要更加准确的定位，你可以重写这个方法。如果 autoresizing 和 constraint不能为你提供你想要做的。你可以自己设置subviews的 frame。你不应该直接调用这个方法，如果你想要强制更新布局，应该调用setNeedsLayout,在下一次绘图更新之前，如果你想要立刻的更新布局，需要调用 layoutIfNeeded setNeedsLayoutInvalidates the current layout of the receiver and triggers a layout update during the next update cycle. DiscussionCall this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.你在想要更新 view 的 subviews 的布局的时候，可以在主线程调用此方法。此方法记录请求并且立即返回。因为这个方法不强制立即更新，而是等待下一个周期更新，你可以使用此方法来让很多 views 的布局失效，并且这样做可以把所有布局更新合并到一个更新周期，这通常会提高性能。 layoutIfNeededLays out the subviews immediately, if layout updates are pending. DiscussionUse this method to force the view to update its layout immediately. When using Auto Layout, the layout engine updates the position of views as needed to satisfy changes in constraints. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root. If no layout updates are pending, this method exits without modifying the layout or calling any layout-related callbacks.使用此方法强制视图立即更新其布局。使用“自动布局”时，布局引擎会根据需要更新视图的位置，以满足约束的更改，使用一个 view 作为 rootView ，此方法从根开始布局视图子树。如果没有约束需要更新，此方法会退出，不会修改 layout 或者调用和此 layout 有关的回调。 stackoverflow上的提问在 stackoverflow上有查到一个问题， How to tell when UITableView has completed ReloadData?，提问的人想要滚动 tableView 到底部，发现调用直接 reloadData，然后滚动没有滚动到最底部，提出了这个问题。 这个下面有很多很多的答案，具体的如下：1.调用layoutIfNeeded强制的刷新布局，接着执行scrollToRowAtIndexPath,滚动到底部，确实是帮助我们解决了这个问题。 [self.tableView reloadData]; [self.tableView layoutIfNeeded]; NSIndexPath* indexPath = [NSIndexPath indexPathForRow: ([self.tableView numberOfRowsInSection:([self.tableView numberOfSections]-1)]-1) inSection: ([self.tableView numberOfSections]-1)]; [self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; 原因： The reload happens during the next layout pass, which normally happens when you return control to the run loop (after, say, your button action or whatever returns).So one way to run something after the table view reloads is simply to force the table view to perform layout immediately重新加载发生在下一个布局过程中，这通常发生在将控制返回到运行循环时（例如，您的按钮操作或任何返回之后）。所以，在tableView reloads 后可以立刻强制更新布局。 调用dispatch_async(dispatch_get_main_queue(), ^{}) [self.tableView reloadData]; dispatch_async(dispatch_get_main_queue(), ^{ NSIndexPath* indexPath = [NSIndexPath indexPathForRow: ([self.tableView numberOfRowsInSection:([self.tableView numberOfSections]-1)]-1) inSection:([self.tableView numberOfSections]-1)]; [self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; }); 原因 depending on how big your table data source is, you can animate going to the bottom of the tableview in the same run loop. If you try your test code with a huge table, your trick of using GCD to delay scrolling until the next run loop will work, whereas immediately scrolling will fail. But anyways, thanks for this trick!但是这种方式并不总是能解决问题,使用GCD来延迟滑动到下一个 runloop，但是立即滑动的话，就会出错。 总结如果你的 tableView 在 reloadData后，无法滑动到底部，那么就可以这样做,在reloadData后，调用 layoutIfNeeded，来强制进行布局，然后在进行 tableView的滑动就可以了。 [self.tableView reloadData]; [self.tableView layoutIfNeeded]; //do somthing you want]]></content>
      <categories>
        <category>UITableView</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode10 【libray not found for -lstdc++.6.0.9 】]]></title>
    <url>%2F2019%2F01%2F08%2FXcode10%20%E3%80%90libray%20not%20found%20for%20-lstdc%2B%2B.6.0.9%20%E3%80%91%2F</url>
    <content type="text"><![CDATA[简介上周在打包上传后，报了一个警告，大致的意思就是这样的：2019年3月必须使用Xcode 10.1或更高版本，此时的我还在用 Xcode 9，刚好最近刚上了包，就升级了Xcode 10 开始采坑1、升级完成后直接报了libray not found for -lstdc++.6.0.9，在 Xcode 10 Release Notes 中有着如下的描述 Building with libstdc++ was deprecated with Xcode 8 and is not supported in Xcode 10 when targeting iOS. C++ projects must now migrate to libc++ and are recommended to set a deployment target of macOS 10.9 or later, or iOS 7 or later. Besides changing the C++ Standard Library build setting, developers should audit hard-coded linker flags and target dependencies to remove references to libstdc++ (including -lstdc++, -lstdc++.6.0.9, libstdc++.6.0.9.tbd, and libstdc++.6.0.9.dylib). Project dependencies such as static archives that were built against libstdc++ will also need to be rebuilt against libc++. (40885260)所以苹果在 Xcode10 中移除了对 libstdc++ 的支持。 2、具体的报错可能会有这些 libray not found for -lstdc++.6.0.9 libray not found for -lstdc++ libray not found for libstdc++.6.0.9.tbd 3、解决办法 在Build Phases -&gt; Link Binary With Libraries 中删除lstdc++、lstdc++.6.0.9、libstdc++.6.0.9.tbd,并且添加libc++。 对于有使用 pod 的项目，在debug.xcconfig和release.xcconfig中也需要删除lstdc++.6.0.9、 4、删除完了这些后还可能编译不成功的问题我在做完这些操作后，我 clean 了项目，然后再次编译的时候，还是有报错，但是其实我已经把引用到这个库的地方都删掉了 我全局搜索了一下，在Build Settings 中找到了这个 接着就是在c++ standard Library 中选择 libc++ ，然后编译，成功解决了报错。 升级后关于Xs Max 和 XR的适配花了一下午的时间升级了Xcode 10,接着就是关于iPhone Xs Max 和XR 的适配了 启动页的分辨率Xs Max: 1242 * 2688XR: 828*1792.png一些判断用的宏#define isPad ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad) #define iPhone5 ([UIScreen mainScreen].bounds.size.height == 568) #define iPhone4 ([UIScreen mainScreen].bounds.size.height == 480) #define iPhone6 ([UIScreen mainScreen].bounds.size.height == 667) #define iPhone6P ([UIScreen mainScreen].bounds.size.height == 736) #define iPhoneX ([UIScreen mainScreen].bounds.size.height == 812) #define iPhoneXR ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(828, 1792), [[UIScreen mainScreen] currentMode].size) &amp;&amp; !isPad : NO) #define iPhoneXsMax ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242, 2688), [[UIScreen mainScreen] currentMode].size)&amp;&amp; !isPad : NO) 脱坑终于完成了 Xcode 9 到 Xcode 10 的迁移，总的来说比之前可能稍微麻烦了一些。在此做个记录 参考xsmax 的宏Xcode 10 升级项目报错]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage 不能及时更新图片]]></title>
    <url>%2F2018%2F12%2F03%2FSDWebImage%20%E4%B8%8D%E8%83%BD%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[问题最近刚好有写到图片需要及时更新的问题，由于 SDWebImage 中的存在缓存，在用户更新了网络头像后，其他人的手机上还是显示了之前的头像，想到了缓存的问题 解决方法后来查到了这种解决方法，SDWebImageDownloader 有一个 headerFilter 属性 /** * Set filter to pick headers for downloading image HTTP request. * * This block will be invoked for each downloading image request, returned * NSDictionary will be used as headers in corresponding HTTP request. */ @property (nonatomic, copy, nullable) SDWebImageDownloaderHeadersFilterBlock headersFilter; 划重点Set filter to pick headers for downloading image HTTP request.，所以我们可以在这里对下载图片的请求头进行一些处理。具体的代码如下： SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader; imgDownloader.headersFilter = ^NSDictionary *(NSURL *url, NSDictionary *headers) { NSFileManager *fm = [[NSFileManager alloc] init]; NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url]; NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey]; NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil]; NSMutableDictionary *mutableHeaders = [headers mutableCopy]; NSDate *lastModifiedDate = nil; if (fileAttr.count &gt; 0) { if (fileAttr.count &gt; 0) { lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate]; } } NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;GMT&quot;]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;]; formatter.dateFormat = @&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;; NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate]; lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @&quot;&quot;; [mutableHeaders setValue:lastModifiedStr forKey:@&quot;If-Modified-Since&quot;]; return mutableHeaders; } 什么是 If-Modified-SinceIf-Modified-Since 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，而在 Last-Modified 首部中会带有上次修改时间。 不同于 If-Unmodified-Since, If-Modified-Since 只可以用在 GET 或 HEAD 请求中。 怎么做所以我们在http 请求的 header 中 加入这个参数，拿到本地缓存图片的修改时间NSFileModificationDate。200 -&gt; 更新图片(已更新)304 -&gt; 使用之前的图片(未更新) 参考SDWebImage支持URL不变时更新图片内容MDN Web 文档]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView 之 表单的自动填充]]></title>
    <url>%2F2018%2F09%2F11%2FUITableView%20%E4%B9%8B%20%E8%A1%A8%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%20%2F</url>
    <content type="text"><![CDATA[简介最近在做一些复杂的表单提交界面，由于 TableView 的复用问题，有了很多的坑，在此做一些记录 入坑前你的页面可能是这个样子的，很常规的，左边名称，右边输入相关的内容。然后你输入了相关的内容，上下滑动页面，然后再划回去。textField 可能清理掉了你输入的值 摆出问题 自动填充textField你可能需要从某个 VC 或者网络接口请求数据，然后自动填充到相关的输入框中，你的 tableView 因为 cell 的复用，导致你修改了自动填充的内容，当你上下滑动表格的时候，它又恢复到了没有修改之前的值。那么你去提交表单的时候，你需要遍历这个表的每一个 textField,然后去取出相应的内容。接下来包成一个 JSON,传给后台 自动填充的一些想法 自动填充 textField界面加载完成后，传统的 MVC 中我们有个 model 来提供数据 。然后通知 UITableView 进行 reloadData,接着调用这个万恶的函数，恰恰就是这个函数让 cell 在复用的过程中，没能正确的显示自动填充的内容。dequeueReusableCellWithIdentifier这个万恶的单元格复用。 -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ TableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;]; //do something } 如果你不使用同一个identifier，那么 tableView 会注册更多的 identifier,可以避免这个问题，但是再次的创建 cell 是需要时间和空间的，如果你的输入框越来越多，难道还要创建越来越多的 cell 么 自动填充的实现思路我的想法是在 textField 输入和 textField 的显示中间，添加 model 作为数据的代理，具体的分为三个部分 监听 textField 的输入，然后通知 model 更新 model reloadData 具体的分为 cell 和 vc 两个部分 ， cell.h@class cellModel; typedef void(^reloadOperation)(void); @interface TableViewCell : UITableViewCell //更新cell 数据，并且在 field 的内容完成输入的时候，通知 VC - (void)updateWithModel:(cellModel *)model FinishLoad:(reloadOperation)reload; cell.m#import &quot;TableViewCell.h&quot; #import &quot;cellModel.h&quot; typedef void(^endEditing) (NSString *text); @interface TableViewCell ()&lt;UITextFieldDelegate&gt; @property (weak, nonatomic) IBOutlet UILabel *name; @property (weak, nonatomic) IBOutlet UITextField *field; @property (copy, nonatomic) endEditing endEditing; @end @implementation TableViewCell -(void)updateWithModel:(cellModel *)model FinishLoad:(reloadOperation)reload{ self.name.text = model.name; self.field.text = model.url; self.field.delegate = self; self.endEditing = ^(NSString *text) { //在输入结束的回调中，更新 model 的相关输入 model.url = text; //通知 VC 需要进行数据的刷新了 reload(); }; } //在输入完成的时候，通知 cell 完成了 field 的输入 -(void)textFieldDidEndEditing:(UITextField *)textField{ self.endEditing(textField.text); } vc.m-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ TableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;]; cellModel *model = self.dataArray[indexPath.row]; [cell updateWithModel:model FinishLoad:^{ NSLog(@&quot;model.text is %@&quot;,model.url); //回调 刷新数据 [tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationNone]; }]; return cell; } 总结tableView 作为一个 iOS 中最常用的控件，还是不希望大家在重用 cell 的时候创建那么多的 identifier。]]></content>
      <categories>
        <category>UITableView</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block的一些理解]]></title>
    <url>%2F2018%2F08%2F31%2FBlock%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Block 与局部变量int global = 100; void(^myBlock)(void) = ^{ NSLog(@&quot;global = %d&quot;,global); }; global = 101; myBlock(); block 可以捕获局部变量，在你声明 myBlock 后，因为需要在block 内使用了 global 变量，所以 block 为你捕获了这个变量。 局部变量的使用1.如果使用 global 变量在使用 clang -rewrite-objc main.m 后查看.cpp 文件可以看到 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int global; //block 捕获了这个变量 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _global, int flags=0) : global(_global) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 2.如果不使用 global 变量struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } };//没有捕获 global 局部变量的修改 直接修改报错，提示缺少了block 的修饰符，那么加了block 修饰符后有什么不一样呢。同样的我们还是查看.cpp 文件来比较使用block | 不使用|—|—|| Block_byref_global_0 global; // by ref | int global;|| __main_block_impl_0(void fp, struct main_block_desc_0 *desc, Block_byref_global_0 _global, int flags=0) : global(_global-&gt;forwarding) |main_block_impl_0(void fp, struct __main_block_desc_0 *desc, int _global, int flags=0) : global(_global) 可以看到 global 由一个值类型变成了一个指针类型的变量，所以使用了__block 后可以修改 global 的值。 局部变量的修改结果1.使用__block 修饰 __block int global = 100; void(^myBlock)(void) = ^{ NSLog(@&quot;global = %d&quot;,global); }; global = 101; myBlock(); //运行结果 global = 101 2.不使用__block 修饰 int global = 100; void(^myBlock)(void) = ^{ NSLog(@&quot;global = %d&quot;,global); }; global = 101; myBlock(); //运行结果 global = 100 修改结果总结 如果使用__block 修饰，并且在调用 block 之前修改 global ，那么block 内部的 global 也会跟着变。 如果不使用__block的话，并且在调用 block 之前修改 global，那么 block 内部的 global 不会发生改变。原因 使用__block 修饰 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_global_0 *global = __cself-&gt;global; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_bq_bv7y3wj94sg1_5ldvtywqy7c0000gn_T_main_b116b4_mi_0,(global-&gt;__forwarding-&gt;global)); } 2.不使用__block修饰 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int global = __cself-&gt;global; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_bq_bv7y3wj94sg1_5ldvtywqy7c0000gn_T_main_62e250_mi_0,global); } 使用block 修饰: Block_byref_global_0 *global = cself-&gt;global; // bound by ref 不使用block 修饰: int global = __cself-&gt;global; // bound by copy划重点，因为一个是bound by ref 一个是bound by copy。一个是传递了指针，一个是对当前捕获的值的拷贝 #Block 与 全局变量在外层定义一个全部变量，执行下面的代码 void(^myBlock)(void) = ^{ NSLog(@&quot;global = %d&quot;,global); }; global = 101; myBlock(); //运行结果 global = 101 为什么不使用__block 也可以修改，我们打开.cpp 进行查看 int global = 100;//先定义了一个全局的变量 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 在block 结构体的上方，已经定义了一个全局的变量，所以直接使用就可以了。不需要像局部变量一样，而且它并没有被 block 所捕获。 Block 与 静态变量定义一个静态变量，执行下面的代码 static int global = 100; void(^myBlock)(void) = ^{ NSLog(@&quot;global = %d&quot;,global); }; global = 101; myBlock(); //运行结果 global = 101 为什么不使用__block 也可以修改，我们打开.cpp 进行查看 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int *global; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_global, int flags=0) : global(_global) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 在 global 进行赋值的时候是这样的 static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int *global = __cself-&gt;global; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_bq_bv7y3wj94sg1_5ldvtywqy7c0000gn_T_main_d41b2e_mi_0,(*global)); } 它和局部变量不使用__block 修饰看起来很像，所以做了下对比 静态全局变量: int *global = cself-&gt;global; // bound by copy不使用block 修饰的局部变量:int global = cself-&gt;global; // bound by copy划重点，虽然都是 copy，但是静态全局变量 copy 了指针，而不使用block修改的局部变量进行了值的 copy。 ARC 下的 Block1.EXC_BAD_ACCESS (code=1, address=0x10)我有一个 User类 user.htypedef void(^nameBlock)(void); @interface User : NSObject @property (nonatomic,strong)NSString *name; @property (nonatomic,copy)nameBlock block; -(instancetype)initWithName:(NSString *)name; @end #user.m #import “User.h” @implementation User -(instancetype)initWithName:(NSString *)name{ self = [super init]; if (self) { _name = name; } return self; } @end 如果不赋值直接调用user.block();那么直接就会报错EXC_BAD_ACCESS (code=1, address=0x10)，在使用时要注意所以在调用 block 之前需要先赋值然后调用，这样就能解决这个问题 2.循环引用 user有一个属性是一个 block，并且在内部又调用了 user，造成了循环引用。在编写代码的时候，编译器就给出了上面的黄色警告。 怎么知道发生了循环引用xcode 9 的话，我们可以打断点看，我们在 autoreleasepool 结束的时候打断点点击 Debug Memory 那个选项本来这个 pool 结束的时候，user 应该被释放掉，但是因为在 block 内部强引用了 user，造成了循环引用。 如果我们去掉 block 内部的那些代码 如果没有了 block 内部对 user 的强引用，那么便不会发生这种情况 如果我们一定要在 block 内部调用 user修改我们的代码 User *user = [[User alloc]initWithName:@&quot;Likee&quot;]; __weak typeof(user)weakUser = user; user.block = ^{ weakUser.name = @&quot;cat&quot;; NSLog(@&quot;name is %@&quot;,weakUser.name); }; NSLog(@&quot;name is %@&quot;,user.name); user.block(); 在 block的内部使用弱引用，这样的话，就能打破这个环。内存图就像下面这个样子 参考内容一篇文章看懂iOS代码块Block]]></content>
      <categories>
        <category>block</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离屏渲染]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[简介最近在看一些离屏渲染的东西，接触到一些新的名词，轻量级别的 CALayer 代替 UIView ，mask ，bitmap 整理下这部分的内容 UIView我们先来看看 UIView 的说明 @interface UIView : UIResponder &lt;NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusItem, CALayerDelegate&gt; UIView 继承了UIResponder，所以 UIView 可以响应用户的一些操作。而且 UIView 遵循代理 CALayerDelegate 。和 CALayer 有了一点点的联系 layer属性1@property(nonatomic, readonly, strong) CALayer *layer; DiscussionThis property is never nil. The actual class of the object is determined by the value returned in the layerClass property. The view is the layer’s delegate. WarningBecause the view is the layer’s delegate, never make the view the delegate of another CALayer object. Additionally, never change the delegate of this layer object. 从文档中可以看出的是，每一个 view.layer都不是 nil,而且这个 view 是 layer 的 &lt;CALayerDelegate&gt; delegate。而且永远不要去改变 这个 layer 的代理 CALayer@interface CALayer : NSObject &lt;NSSecureCoding, CAMediaTiming&gt; CALayer继承于 NSObject ，无法响应用户的操作。 Overview A layer’s main job is to manage the visual content that you provide but the layer itself has visual attributes that can be set, such as a background color, border, and shadow. In addition to managing visual content, the layer also maintains information about the geometry of its content (such as its position, size, and transform) that is used to present that content onscreen.If the layer object was created by a view, the view typically assigns itself as the layer’s delegate automatically, and you should not change that relationship. 从 Overview 中截取了一部分，layer 的首要任务就是管理你提供的那些内容，当然它本身也可以设置一些显示的属性，比如 color、border、shadow 等。当然 layer 也帮助你管理显示在屏幕的内容。像是位置、大小和一些变换的东西 layer 中一些触发离屏渲染的属性mask1@property(strong) CALayer *mask; The layer’s alpha channel determines how much of the layer’s content and background shows through. Fully or partially opaque pixels allow the underlying content to show through but fully transparent pixels block that content. mask 也是一个 CALayer, mask 代表着怎么样的像素能够穿过 mask 被显示出来。你一定写过这样的代码。 imageView.image.layer.cornerRadius = 5; imageView.image.layer.masksToBounds = YES; 我们来分别看看这两行代码代表什么，设置圆角，然后进行裁剪显示出来圆角 1.cornerRadius Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to YES causes the content to be clipped to the rounded corners. 划重点，在默认情况下，cornerRadius 不会对 layer 的内容是 image 生效的，但是只要你设置 masksToBounds 为 YES,那么这样就是可行的 2.masksToBounds When the value of this property is YES, Core Animation creates an implicit clipping mask that matches the bounds of the layer and includes any corner radius effects. If a value for the mask property is also specified, the two masks are multiplied to get the final mask value.如果设置了masksToBounds 为 YES，那么 Core Animation 就会隐式的创建一个 与 layer 的 bounds 相匹配的并且裁切过的 mask，这个 mask 就可以实现圆角的效果 shadow1. shadowOpacity The opacity of the layer’s shadow. Animatable.设置 layer 的不透明度 2.shadowRadius The blur radius (in points) used to render the layer’s shadow. Animatable.用来进行阴影半径渲染的模糊半径 3. shadowOffset The offset (in points) of the layer’s shadow. Animatable.设置 layer 的阴影偏移量 edgeAntialiasingedgeAntialiasingMask This property specifies which edges of the layer are antialiased and is a combination of the constants defined in CAEdgeAntialiasingMask. You can enable or disable antialiasing for each edge (top, left, bottom, right) separately. By default antialiasing is enabled for all edges.通过这个属性可以对某一个或者某几个边启用或者不启用抗锯齿，当然默认是对所有的生效 allowsEdgeAntialiasing When the value is YES, the layer is allowed to antialias its edges, as requested by the value in the layer’s edgeAntialiasingMask property. The default value is read from the boolean UIViewEdgeAntialiasing property in the main bundle’s Info.plist file. If no value is found, the default value is NO.开启了抗锯齿的话，就回去访问edgeAntialiasingMask，看看会有那些边开启抗锯齿 group opacityallowsGroupOpacity@property BOOL allowsGroupOpacity; When the value is YES and the layer’s opacity property value is less than 1.0, the layer is allowed to composite itself as a group separate from its parent. This gives correct results when the layer contains multiple opaque components, but may reduce performance.如果设置 allowsGroupOpacity为 YES 并且 layer 的opacity小于1，那么该layer将 被允许将其自身合并为一个组，并且是与他的parent分开的。而且需要注意的是，如果这个 layer 还包含很多的不透明的子 layer 的话，那么就会牺牲一些性能。而在 iOS 7＋ ,这个属性默认为 YES 。 bitmaplayer 中有个属性 contents Declaration1@property(strong) id contents; Discussion If you are using the layer to display a static image, you can set this property to the CGImageRefcontaining the image you want to display. (In macOS 10.6 and later, you can also set the property to an NSImage Assigning a value to this property causes the layer to use your image rather than create a separate backing store. contents 可以设置一个静态的图片，传入一个CGImageRef。打开这个CGImageRef会发现这样的一段描述 CGImageRefStructureA bitmap image or image mask. typedef struct CF_BRIDGED_TYPE(id) CGImage *CGImageRef; 这是个指向 CGImage 结构体的指针 CGImage A bitmap (or sampled) image is a rectangular array of pixels, with each pixel representing a single sample or data point in a source image. 一个 bitmap image 就是一个矩形像素阵列，每个像素表示源图像中的单个样本或数据点。 总结最近在接触一些离屏渲染的东西，看到这些陌生的名词。先动手整理了下，方便以后查看。先写到这里，各位大佬轻拍]]></content>
      <categories>
        <category>UIView</category>
      </categories>
      <tags>
        <tag>UIView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信分享长图]]></title>
    <url>%2F2018%2F08%2F17%2F%20%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E9%95%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[#1.简介项目中有微信分享的相关内容，要求分享长截图到微信，要求截取 tableView 的全部内容并且底部加上二维码。做的过程中有一些问题，做下记录。 #2.步骤1.截取 tableView 的内容，并且生成一张图片2.生成底部的分享二维码的图片3.对这些图片进行拼接4.分享 #3.过程中遇到的一些问题 ##1.如何生成 tableView 的长截图TYSnapshotScroll，前人已经为你准备好了工具，直接使用即可 如何自己绘制这张长截图我们可以使用 Quartz2D 提供的相关 API进行绘制。下文中的 self指代的是 tableView 1.创建上下文，设置这个 bitmap 的size 、opaque和scale。注:(scale 建议设置为 [UIScreen mainScreen].scale)，如果 scale设置的不对，那么你最后得到的图片就会很模糊。 UIGraphicsBeginImageContextWithOptions(self.bounds.size,NO,[UIScreen mainScreen].scale); 2.将 layer 渲染到当前的上下文中 [self.layer renderInContext: UIGraphicsGetCurrentContext()]; 3.从上下文获取制作好的图片，这就是你需要的 snapshotImage = UIGraphicsGetImageFromCurrentImageContext(); 4.关闭这个上下文 UIGraphicsEndImageContext(); 2.我们的二维码是UI给的图，我们需要做的就是将这两个 image 合成为一张如何合成直接使用TYSnapshotScroll,有个 UIImage 的扩展方法，可以直接使用图片集合将好几张图合成为一张。（这里有个坑，就是两张 image 可以合成，但是他们都会保持自己的大小,你可能会发现你的截屏图片的宽度==屏幕宽度，但是 UI 给的二维码图 ！= 屏幕宽度） 徒手绘制思路1.创建一个 size ,计算两个图片的总长度2.创建一个用来绘制的上下文3.绘制这两张图片到上下文4.拿出合成后的图片5.关闭上下文 CGSize contentSize = CGSizeMake(snapshotImage.size.width, snapshotImage.size.height + 80); UIGraphicsBeginImageContextWithOptions(contentSize, NO, [UIScreen mainScreen].scale); [snapshotImage drawInRect:CGRectMake(0, 0, snapshotImage.size.width, snapshotImage.size.height)]; [footerImage drawInRect:CGRectMake(0,snapshotImage.size.height, snapshotImage.size.width, 80)]; UIImage *resultingImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); 如何在 debug 的时候查看绘制好的这个图片4.微信分享- (void)WXShareImageWithSence:(BOOL)isSession{ WXMediaMessage *message = [WXMediaMessage message]; WXImageObject *ext = [WXImageObject object]; //图片 NSData *imageData = UIImagePNGRepresentation(self.shareImage); //缩略图 UIImage *tubmbImage = [self compressImage:self.shareImage toByte:31 *1024]; ext.imageData = imageData; // 缩略图 小于32KB message.mediaObject = ext; [message setThumbImage:tubmbImage]; SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init]; req.bText = NO; req.scene = isSession ? WXSceneSession : WXSceneTimeline; req.message = message; [WXApi sendReq:req]; }]]></content>
      <categories>
        <category>UIView</category>
      </categories>
      <tags>
        <tag>UIView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView 之 UITextView 自动行高的实现]]></title>
    <url>%2F2018%2F07%2F19%2FUITableView%20%E4%B9%8B%20UITextView%20%E8%87%AA%E5%8A%A8%E8%A1%8C%E9%AB%98%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[简介开发中会大量的使用 UITableView，当我们有很多的cell,每一行都有一个 UITextView 用来进行稍微重一些的文本编辑，这个时候，你的产品经理突然给你说，我希望这个 UITextView会随着书写内容的长度而自动的增高。(꒪ꇴ꒪(꒪ꇴ꒪ ;)哈? 为什么要写这个因为我自己也找了好久，参照过别人写的一些，但是到我这里都不是特别的实用，尤其是进行数据刷新的时候，如果你的行高需要改变，你去 reloadData这个时候，键盘会失去响应。就算你这个时候再次将键盘设置为 firstResponser,这个时候你的键盘还是会闪一下，不是很自然。所以写了一些小的 demo ，下面的具体代码也是针对这个 demo 的，点击这里下载 思路 首先对 TextView 的输入进行监听，判断输入的字数的多少 根据 UITextView 的字数的多少去动态的修改 UITextView 的 frame 监听 UITextView 的高度变化，如果 UITextView 比你的 cell 还要高的时候，你需要动态的去更新你的 UITableViewCell 的高度 实现1.对 UITextView 的输入进行监听，判断输入的字数的多少前人已经有了现成的轮子，所以不需要你重复的造轮子。这里找到一个很好的自动换行的 TextView我们需要使用这个来完成我们接下来的工作 [textView wzb_autoHeightWithMaxHeight:300 textViewHeightDidChanged:^(CGFloat currentTextViewHeight) { //在此处我们已经对 UITextView 完成了监听，接下来我们就可以修改 UITextView 的 frame 了 }]; 2.根据 UITextView 的字数的多少去动态的修改 UITextView 的 frame__weak typeof (self)WeakSelf = self; __weak typeof (textView)WeakTextView = textView; [textView wzb_autoHeightWithMaxHeight:300 textViewHeightDidChanged:^(CGFloat currentTextViewHeight) { CGRect frame = WeakTextView.frame; frame.size.height = currentTextViewHeight; [UIView animateWithDuration:0.2 animations:^{ WeakTextView.frame = frame; } completion:^(BOOL finished) { }]; }]; 3.动态的修改cell 的高度我们需要对单元格的高度进行保存，然后在刷新行高的时候把高度取出来赋值。所以我们还需要一个保存高度的字典dicHeight __weak typeof (self)WeakSelf = self; __weak typeof (textView)WeakTextView = textView; // 最大高度为300 改变高度的 block [textView wzb_autoHeightWithMaxHeight:300 textViewHeightDidChanged:^(CGFloat currentTextViewHeight) { CGRect frame = WeakTextView.frame; frame.size.height = currentTextViewHeight; [UIView animateWithDuration:0.2 animations:^{ WeakTextView.frame = frame; } completion:^(BOOL finished) { }]; NSString *key = [NSString stringWithFormat:@&quot;%@&quot;,indexPath]; NSNumber *height = [NSNumber numberWithFloat:currentTextViewHeight]; if (WeakSelf.dicHeight[key]) { NSNumber *oldHeight = self.dicHeight[key]; if (oldHeight.floatValue != height.floatValue) { [WeakSelf.dicHeight setObject:height forKey:key]; } } else{ [WeakSelf.dicHeight setObject:height forKey:key]; } [WeakSelf.tableview beginUpdates]; [WeakSelf.tableview endUpdates]; }]; 我们使用beginUpdates 和 endUpdates 。不使用 reloadData。具体的原因看我之前写的为什么不用 ReloadData。 接下来就可以修改行高了 -(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{ NSString *key = [NSString stringWithFormat:@&quot;%@&quot;,indexPath]; if(self.dicHeight[key]){ NSNumber *number = self.dicHeight[key]; if (number.floatValue &gt; 44) { return number.floatValue; } } return 44; } 小彩蛋通过这个你就可以简单的知道为什么不能用 reloadData了。使用的时候把自动行高的哪里注释掉。简单的输入一些东西做一些尝试吧。 //模拟数据刷新 -(void)textViewDidChange:(UITextView *)textView{ //1.reloadData //[self.tableview reloadData]; //2.reloadindexpath // NSIndexPath *index = [NSIndexPath indexPathForRow:0 inSection:0]; // [self.tableview reloadRowsAtIndexPaths:@[index] withRowAnimation:UITableViewRowAnimationTop]; //3.beginupdate &amp; endupdate // [self.tableview beginUpdates]; // [self.tableview endUpdates]; } 总结UITableView 作为 iOS 开发中用到的比较多的控件，在具体的使用中总会出现各种各样的问题，自动行高这里总算是脱坑了。先写到这里]]></content>
      <categories>
        <category>UITableView</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView 之 正确的 reloadData]]></title>
    <url>%2F2018%2F07%2F17%2FUITableView%20%E4%B9%8B%20%E6%AD%A3%E7%A1%AE%E7%9A%84%20reloadData%2F</url>
    <content type="text"><![CDATA[1. tableview reloadData假设你有一个 tableview ，你的 cell 中有 UITextField 或者 UITextView,而且你在编辑这一行的数据。此时对文本框进行监听，然后调用了 reloadData，键盘就消失了。 /*Reloads everything from scratch. Redisplays visible rows. Note that this will cause any existing drop placeholder rows to be removed.*/ - (void)reloadData; api里面是这么描述的 Call this method to reload all the data that is used to construct the table, including cells, section headers and footers, index arrays, and so on. For efficiency, the table view redisplays only those rows that are visible. It adjusts offsets if the table shrinks as a result of the reload. The table view’s delegate or data source calls this method when it wants the table view to completely reload its data. It should not be called in the methods that insert or delete rows, especially within an animation block implemented with calls to beginUpdates and endUpdates. 划重点:Call this method to reload all the data that is used to construct the table, including cells, section headers and footers, index arrays, and so on..在你进行编辑的时候，你的 cell 中的UITextView或者UITextField是 first responder。但是 reloadData reload了所有的数据，包括了你的表头，表尾，单元格等所有的数据。因为你的单元格要被重载，所以你的UITextView和UITextField就不是 first responder。那么相应的表现出来的就是你的键盘会被收起来 2. tableview reloadRowsAtIndexPaths:withRowAnimation:api 里面的描述 Reloading a row causes the table view to ask its data source for a new cell for that row. The table animates that new cell in as it animates the old row out. Call this method if you want to alert the user that the value of a cell is changing. If, however, notifying the user is not important—that is, you just want to change the value that a cell is displaying—you can get the cell for a particular row and set its new value. 划重点：Reloading a row causes the table view to ask its data source for a new cell for that row. The table animates that new cell in as it animates the old row out. 假设你在编辑 A行的数据，此时A中有和这个数据绑定的刷新,那么你reloadRowsAtIndexPaths:withRowAnimation 。你调用此方法会导致旧的cell消失，而新的 cell出现后并没有被注册成为 first responder 。所以键盘也会消失。 但是在 A行刷新 B行的数据，则不会出现此问题。 3.table beginUpdates &amp; endUpdates关于 beginUpdates 的描述 Call this method if you want subsequent insertions, deletion, and selection operations (for example, cellForRowAtIndexPath: and indexPathsForVisibleRows) to be animated simultaneously. You can also use this method followed by the endUpdates method to animate the change in the row heights without reloading the cell. This group of methods must conclude with an invocation of endUpdates. These method pairs can be nested. If you do not make the insertion, deletion, and selection calls inside this block, table attributes such as row count might become invalid. You should not call reloadData within the group; if you call this method within the group, you must perform any animations yourself. 划重点： You can also use this method followed by the endUpdates method to animate the change in the row heights without reloading the cell假设你需要动态的修改 cell 的高度，你可以调用此方法，这样就可以动态的改变单元格的高度。如果你需要一组动画，同时进行插入和删除的话，那么也可以使用这个方法。但是不要在此调用reloadData方法，如果你需要reloadData 在此方法中，那么你需要自己实现动画 总结最近在 tableview中挣扎了好久，闲下来把 tableview 数据刷新的一些坑整理了一下。接下来还有动态单元格，抽空也尽量的都写出来。尽量少让后人采坑]]></content>
      <categories>
        <category>UITableView</category>
      </categories>
      <tags>
        <tag>UITableView</tag>
      </tags>
  </entry>
</search>
