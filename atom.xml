<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LikeeCat&#39;s Blog</title>
  
  <subtitle>音乐 | 摄影 | 游戏 | 努力努力再努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LikeeCat.github.io/"/>
  <updated>2021-01-17T06:36:55.676Z</updated>
  <id>http://LikeeCat.github.io/</id>
  
  <author>
    <name>LikeeCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>141. Linked List Cycle</title>
    <link href="http://LikeeCat.github.io/2021/01/17/141.%20Linked%20List%20Cycle/"/>
    <id>http://LikeeCat.github.io/2021/01/17/141. Linked List Cycle/</id>
    <published>2021-01-17T09:05:13.000Z</published>
    <updated>2021-01-17T06:36:55.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/141/141题目.png" alt="题目"><br><a id="more"></a></p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>去判断链表是否包含环这种问题,比较适合用快慢指针来做</li><li>slow每次走一步,fast每次走两步,那么fast必然会先进入环中,随后slow也会进入环中</li><li>由于两者指针的速度不一致,在经过一定的步数后,两者一定会相遇</li></ol><h1 id="具体解释"><a href="#具体解释" class="headerlink" title="具体解释"></a>具体解释</h1><p>可以查看第二种解法<a href="https://leetcode.com/problems/linked-list-cycle/solution" target="_blank" rel="noopener">Approach 2: Floyd’s Cycle Finding Algorithm</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution {   func hasCycle(_ head: ListNode?) -&gt; Bool {         if head == nil || head?.next == nil{            return false;        }        var slow = head;        var fast = head?.next;        while slow !== fast {            //if fast is nil list has no cycle            if fast == nil || fast?.next == nil {                return false;            }            slow = slow?.next;            fast = fast?.next?.next;        }        return true    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/141/141题目.png&quot; alt=&quot;题目&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
      <category term="link list" scheme="http://LikeeCat.github.io/tags/link-list/"/>
    
  </entry>
  
  <entry>
    <title>160. Intersection of Two Linked Lists</title>
    <link href="http://LikeeCat.github.io/2021/01/16/160.%20Intersection%20of%20Two%20Linked%20Lists/"/>
    <id>http://LikeeCat.github.io/2021/01/16/160. Intersection of Two Linked Lists/</id>
    <published>2021-01-16T09:05:13.000Z</published>
    <updated>2021-01-17T07:13:07.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/160/160题目.png" alt="题目"></p><a id="more"></a><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从给出的内容来看,我们需要找到两个链表相交节点</li><li>那么我们可以吧a和b相连,将b和a相连,如果他们两个链表相交,那么他们的尾部肯定是相同的<br><img src="/assets/img/160/160图解.jpeg" alt="思路1"></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution {    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -&gt; ListNode? {        if headA == nil || headB == nil {            return nil        }        var pointerA = headA;        var pointerB = headB;        var tagA  = 0;        var tagB = 0;        while pointerB !== pointerA {                //避免因为没有共同节点造成死循环            if tagA == 2 &amp;&amp; tagB == 2 {                return nil;            }            pointerA = pointerA == nil ? headB : pointerA?.next            if pointerA === headB {                tagA = tagA + 1            }            pointerB = pointerB == nil ? headA : pointerB?.next            if pointerB === headA {                tagB = tagB + 1            }        }        return pointerA;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/160/160题目.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
      <category term="link list" scheme="http://LikeeCat.github.io/tags/link-list/"/>
    
  </entry>
  
  <entry>
    <title>21. Merge Two Sorted Lists</title>
    <link href="http://LikeeCat.github.io/2021/01/10/21.Merge%20Two%20Sorted%20Lists/"/>
    <id>http://LikeeCat.github.io/2021/01/10/21.Merge Two Sorted Lists/</id>
    <published>2021-01-10T06:05:13.000Z</published>
    <updated>2021-01-10T06:50:53.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/21/21题目.png" alt></p><a id="more"></a><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>首先这是两个分别排好序的数组</li><li>我们需要去遍历这两个链表,比较两个值的大小,然后插入新的链表中</li><li>注意一些可选值的判断</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>class Solution { func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? {    let headerNode = ListNode        .init();    var headerPoint = headerNode;    var l1Pointer = l1    var l2Pointer = l2    while l1Pointer != nil || l2Pointer != nil {        if l1Pointer != nil &amp;&amp; l2Pointer != nil{            if l1Pointer!.val &gt;= l2Pointer!.val {                headerPoint.next = l2Pointer                l2Pointer = l2Pointer?.next            }            else{                headerPoint.next = l1Pointer                l1Pointer = l1Pointer?.next            }        }        else{            if l1Pointer == nil {                headerPoint.next = l2Pointer                l2Pointer = l2Pointer?.next            }            else{                headerPoint.next = l1Pointer                l1Pointer = l1Pointer?.next            }        }        headerPoint = headerPoint.next!;    }    return headerNode.next;}}</code></pre><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol><li>可选值的判读        </li></ol><h1 id="swift-中-if-let-guard-let-的使用"><a href="#swift-中-if-let-guard-let-的使用" class="headerlink" title="swift 中 if let ,guard let 的使用"></a>swift 中 if let ,guard let 的使用</h1><h2 id="1-if-和-if-let-的区别"><a href="#1-if-和-if-let-的区别" class="headerlink" title="1. if 和 if let 的区别"></a>1. if 和 if let 的区别</h2><pre><code>    let name: String? = &quot;likee&quot;    let age: Int? = 20    //if             if name != nil &amp;&amp; age != nil {        print(name! + String(age!))     // 输出:likee 20    }    //if let    if let nameNew = name,    let ageNew = age {    // 肯定是有值的    print(nameNew + String(ageNew)) // 输出:likee 20}</code></pre><h2 id="guard-let-和-if-let-的区别"><a href="#guard-let-和-if-let-的区别" class="headerlink" title="guard let 和 if let 的区别"></a>guard let 和 if let 的区别</h2><pre><code> guard let nameNew = name,let ageNew = age else {    //在不满足条件后,会直接返回    print(&quot;姓名 或 年龄 为nil&quot;)    return //注意 }// 代码执行至此, nameNew 和 ageNew 一定有值print(nameNew + String(ageNew))     // 输出:likee 20</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/21/21题目.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
      <category term="link list" scheme="http://LikeeCat.github.io/tags/link-list/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="http://LikeeCat.github.io/2020/12/13/206.%20Reverse%20Linked%20List/"/>
    <id>http://LikeeCat.github.io/2020/12/13/206. Reverse Linked List/</id>
    <published>2020-12-13T09:05:13.000Z</published>
    <updated>2021-01-10T06:00:50.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/206题目.png" alt="题目"></p><a id="more"></a><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从给出的内容来看,考的链表的一些知识,但是这个后进先出的结构特性,让我想起来了stack</li><li>如果节点不为空,就把节点压入栈中,最后,将节点之间按照数组的先后顺序进行连接</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     public var val: Int *     public var next: ListNode? *     public init() { self.val = 0; self.next = nil; } *     public init(_ val: Int) { self.val = val; self.next = nil; } *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; } * } */class Solution {  var stack :[ListNode] = [];  func reverseList(_ head: ListNode?) -&gt; ListNode? {      var tmp = head      //一直将所有的node压入栈,直到node没有下一个node      while  tmp != nil{          stack.insert(tmp!, at: 0)          tmp = tmp?.next      }      //开始将各个node按照数组的先后顺序进行连接    for i in stride(from: 0, through: stack.count - 1, by: 1) {        let node = stack[i]        if(i == stack.count - 1){            node.next = nil;        }        else{            node.next = stack[i+1];        }    }     //返回数组的首个元素      return stack.first;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/206题目.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>136. Single Number</title>
    <link href="http://LikeeCat.github.io/2020/12/13/136.%20Single%20Number/"/>
    <id>http://LikeeCat.github.io/2020/12/13/136. Single Number/</id>
    <published>2020-12-13T09:05:13.000Z</published>
    <updated>2021-01-17T06:45:35.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/136题目.png" alt="题目"></p><a id="more"></a><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从给出的内容来看,要找到数组中只出现一次的数</li><li>用字典去记录每一个数字出现的频率,大于1就从字典中删除,最后字典剩下的就是我们需要的target</li><li>题目中还有Follow up,让我们尝试不用多余的内存去做</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p><img src="/assets/img/136思路2.png" alt="思路1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution {    var dic :[Int:Int] = [:]    func singleNumber(_ nums: [Int]) -&gt; Int {        for i in nums{            if dic.keys.contains(i) {                dic.removeValue(forKey: i)            }            else{                dic[i] = 1;            }            }        return Int(dic.keys.first!);    }}</code></pre><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p><img src="/assets/img/136思路1.png" alt="思路2"></p><h1 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h1><pre><code>class Solution {func singleNumber(_ nums: [Int]) -&gt; Int {    var  a = 0    for i in nums{        a = a ^ i    }    return a;    }}</code></pre><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>这里用到了异或的计算,计算法则如下,具体的细则可以<a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin" target="_blank" rel="noopener">点击这里</a><br><img src="/assets/img/136异或运算.png" alt="运算法则"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/136题目.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>101. Symmetric Tree</title>
    <link href="http://LikeeCat.github.io/2020/12/13/101.%20Symmetric%20Tree/"/>
    <id>http://LikeeCat.github.io/2020/12/13/101. Symmetric Tree/</id>
    <published>2020-12-13T08:05:13.000Z</published>
    <updated>2021-01-10T06:00:32.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/101题目.png" alt="题目"></p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从给出的内容来看,看这个二叉树是不是一个镜像的二叉树,即它的左子树与右子树之间是<code>对称</code>的</li><li>那么他的左子树和右子树是镜像的,对于一个三层的二叉树来说就是,左子树的左侧节点和右子树的右侧节点是一致的,左子树的右侧节点和右子树的左侧节点是一致的<a id="more"></a></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="/assets/img/101思路.png" alt="思路"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     public var val: Int *     public var left: TreeNode? *     public var right: TreeNode? *     public init() { self.val = 0; self.left = nil; self.right = nil; } *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; } *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) { *         self.val = val *         self.left = left *         self.right = right *     } * } */ class Solution {  func isMirror(_ left:TreeNode?,_ right:TreeNode?) -&gt; Bool {    if left == nil &amp;&amp; right == nil {        return  true    }    if left == nil || right == nil {        return false    }    return (left?.val == right?.val) &amp;&amp; isMirror(left?.right, right?.left) &amp;&amp; isMirror(left?.left, right?.right)    }    func isSymmetric(_ root: TreeNode?) -&gt; Bool {            return isMirror(root,root)    }}</code></pre><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>这道题的重点还是要理解两个子树之间的关系,即怎样的两个子树即可互为镜像</p><pre><code>1. Their two roots have the same value2. The right subtree of each tree is a mirror reflection of the other tree</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/101题目.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一些思考&quot;&gt;&lt;a href=&quot;#一些思考&quot; class=&quot;headerlink&quot; title=&quot;一些思考&quot;&gt;&lt;/a&gt;一些思考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;从给出的内容来看,看这个二叉树是不是一个镜像的二叉树,即它的左子树与右子树之间是&lt;code&gt;对称&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;那么他的左子树和右子树是镜像的,对于一个三层的二叉树来说就是,左子树的左侧节点和右子树的右侧节点是一致的,左子树的右侧节点和右子树的左侧节点是一致的
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>20. Valid Parentheses</title>
    <link href="http://LikeeCat.github.io/2020/12/13/Valid%20Parentheses/"/>
    <id>http://LikeeCat.github.io/2020/12/13/Valid Parentheses/</id>
    <published>2020-12-13T07:05:13.000Z</published>
    <updated>2021-01-10T06:00:44.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/20题目.png" alt="图"></p><a id="more"></a><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从题目给出的意思来看的话,这道题就是用Close brackets 来匹配 Open brackets,那么这个数组的数目必须是偶数个,否则肯定无法匹配</li><li>如果刚开始就是Close bracket那么也无法匹配</li><li>Open brackets 需要优先去匹配离他最近的 Close bracket,且中间不能有其他未匹配完的符号</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="/assets/img/20思路.png" alt="思路"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>class Solution {//存放未匹配到Close brackets 的数组var element:[Character] = []//匹配字符串用到的字典let validDic:[String:Character] = [&quot;[&quot;:&quot;]&quot;,&quot;{&quot;:&quot;}&quot;,&quot;(&quot;:&quot;)&quot;]func isValid(_ s: String) -&gt; Bool {    for i in s{            //如果是Open bracket,就放入brackets的数组        if i == &quot;[&quot; || i == &quot;{&quot; || i == &quot;(&quot;{            self.element.append(i)        }        else{                //如果Stack为空,那么就不匹配            if self.element.isEmpty {                return false            }            else{                    //找到栈顶的元素,与当前的i进行对比                let lastElement = String(self.element.last!)                if validDic[String.init(lastElement)] == i  {                    self.element.removeLast()                }                else{                    return false                }            }        }    }    //如果栈中不存在任何的元素,则证明匹配成功    return self.element.isEmpty}}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/20题目.png&quot; alt=&quot;图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>NSDictionary 使用中的一些问题</title>
    <link href="http://LikeeCat.github.io/2020/07/29/NSDictionary%20%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://LikeeCat.github.io/2020/07/29/NSDictionary 使用中的一些问题/</id>
    <published>2020-07-29T10:05:13.000Z</published>
    <updated>2021-01-10T06:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NSDictionary-使用中的一些问题"><a href="#NSDictionary-使用中的一些问题" class="headerlink" title="NSDictionary 使用中的一些问题"></a>NSDictionary 使用中的一些问题</h1><h2 id="1-dictionaryWithObjectsAndKeys"><a href="#1-dictionaryWithObjectsAndKeys" class="headerlink" title="1. dictionaryWithObjectsAndKeys"></a>1. dictionaryWithObjectsAndKeys</h2><pre><code>NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;12&quot;,@&quot;key&quot;,&quot;11&quot;,@&quot;age&quot;,nil];NSLog(@&quot;dic is %@&quot;,dic);</code></pre><p>我们在使用<code>dictionaryWithObjectsAndKeys</code>或者一些其他字面量去创建OC对象的时候，参数应该是<strong><em>Objective-C字符串</em></strong>，不是<strong><em>C语言</em></strong>的字符串<br><a id="more"></a></p><p>##2. 关于NSDictionary 转 JSON字符串的坑<br>我们经常能在网上搜到下面的内容</p><pre><code>-(NSString*)convertAlfredaJsonString:(NSDictionary *)dic{    NSString *jsonString = nil;    NSError *error;    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic                                                   options:NSJSONWritingPrettyPrinted                                                     error:&amp;error];    if (!jsonData) {        return @&quot;&quot;;    }     else {        jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];    }    return jsonString;}</code></pre><p>##坑<br>在你使用上面代码的时候，你生成的 json字符串中会带有<code>&quot;\n&quot;</code>的换行符，因为这个换行符，因为web、后端可能对换行符进行了一些处理，直接这么传过去，可能会出现问题</p><h2 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h2><pre><code>NSMutableString *occultStr = [NSMutableString stringWithString:jsonString];NSRange range = {0,jsonString.length};//去掉字符串中的空格[occultStr replaceOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot; options:NSLiteralSearch range:range];NSRange range2 = {0,occultStr.length};[occultStr replaceOccurrencesOfString:@&quot;\n&quot; withString:@&quot;&quot; options:NSLiteralSearch range:range2];</code></pre><p>在生成 json字符串后，将其中的<code>&quot;\n&quot;</code>、<code>&quot; &quot;</code>空格去掉，然后再传给后端</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NSDictionary-使用中的一些问题&quot;&gt;&lt;a href=&quot;#NSDictionary-使用中的一些问题&quot; class=&quot;headerlink&quot; title=&quot;NSDictionary 使用中的一些问题&quot;&gt;&lt;/a&gt;NSDictionary 使用中的一些问题&lt;/h1&gt;&lt;h2 id=&quot;1-dictionaryWithObjectsAndKeys&quot;&gt;&lt;a href=&quot;#1-dictionaryWithObjectsAndKeys&quot; class=&quot;headerlink&quot; title=&quot;1. dictionaryWithObjectsAndKeys&quot;&gt;&lt;/a&gt;1. dictionaryWithObjectsAndKeys&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@&amp;quot;12&amp;quot;,@&amp;quot;key&amp;quot;,&amp;quot;11&amp;quot;,@&amp;quot;age&amp;quot;,nil];
NSLog(@&amp;quot;dic is %@&amp;quot;,dic);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们在使用&lt;code&gt;dictionaryWithObjectsAndKeys&lt;/code&gt;或者一些其他字面量去创建OC对象的时候，参数应该是&lt;strong&gt;&lt;em&gt;Objective-C字符串&lt;/em&gt;&lt;/strong&gt;，不是&lt;strong&gt;&lt;em&gt;C语言&lt;/em&gt;&lt;/strong&gt;的字符串&lt;br&gt;
    
    </summary>
    
      <category term="tip" scheme="http://LikeeCat.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://LikeeCat.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>iOS中framework的相关命令</title>
    <link href="http://LikeeCat.github.io/2020/07/25/iOS%E4%B8%ADframework%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>http://LikeeCat.github.io/2020/07/25/iOS中framework的相关命令/</id>
    <published>2020-07-25T10:05:13.000Z</published>
    <updated>2021-01-10T06:01:04.965Z</updated>
    
    <content type="html"><![CDATA[<p>#查看framework支持的处理器架构</p><ol><li><p>进入framework的目录下面 </p><pre><code>cd /xxx/xxx.framework</code></pre></li><li><p>输入命令</p><pre><code>lipo -info xxxframework //这里的xxxframwork 是指framework中的二进制</code></pre></li></ol><a id="more"></a><h1 id="查看framework是静态库还是动态库"><a href="#查看framework是静态库还是动态库" class="headerlink" title="查看framework是静态库还是动态库"></a>查看framework是静态库还是动态库</h1><ol><li><p>输入命令</p><pre><code>file xxx/xxxframework //这里的xxxframework 是指framework中的二进制</code></pre></li></ol><p>#查看framework 中是否包含UIWebView</p><ol><li><p>进入项目目录下面 </p><pre><code>cd /xxx/xxx.framework</code></pre></li><li><p>输入命令</p><pre><code>find . -type f | grep -e &quot;.a&quot; -e &quot;.framework&quot; | xargs grep -s UIWebView</code></pre></li></ol><p>#xxx.framework contains unsupported architectures ‘[x86_64, i386]’</p><p>这个framework中包含x86_64, i386架构,这个在iOS中是不允许的</p><ol><li>在app对应的target -&gt; build phases -&gt; new Run Script Phase</li><li><p>输入命令</p><pre><code># Without further ado, here’s the script. Add a Run Script step to your build steps, put it after your step to embed frameworks, set it to use /bin/sh and enter the following script:APP_PATH=&quot;${TARGET_BUILD_DIR}/${WRAPPER_NAME}&quot;# This script loops through the frameworks embedded in the     application and# removes unused architectures.find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;EXTRACTED_ARCHS=()for ARCH in $ARCHSdo    echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)doneecho &quot;Merging extracted architectures: ${ARCHS}&quot;lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;${EXTRACTED_ARCHS[@]}&quot;rm &quot;${EXTRACTED_ARCHS[@]}&quot;echo &quot;Replacing original executable with thinned version&quot;rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;done</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#查看framework支持的处理器架构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入framework的目录下面 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /xxx/xxx.framework
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输入命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lipo -info xxxframework //这里的xxxframwork 是指framework中的二进制
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="frame" scheme="http://LikeeCat.github.io/categories/frame/"/>
    
    
      <category term="framework" scheme="http://LikeeCat.github.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>github下载代码太慢</title>
    <link href="http://LikeeCat.github.io/2020/06/23/github%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2/"/>
    <id>http://LikeeCat.github.io/2020/06/23/github下载太慢/</id>
    <published>2020-06-23T10:05:13.000Z</published>
    <updated>2021-01-10T06:01:18.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>我们总是需要在github去下载一些代码,但是因为一些原因,下载的速度忽快忽慢,而一些第三方的网站号称可以代下载,但是也是会很慢,或者直接就下载不下来,这个时候我们就需要用到<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>来帮助我们下载.接下来我们以CocoaPods为例</p><a id="more"></a><h2 id="1-获取github的仓库地址"><a href="#1-获取github的仓库地址" class="headerlink" title="1.获取github的仓库地址"></a>1.获取github的仓库地址</h2><p><img src="/assets/img/clone Url.png" alt="仓库地址"></p><h2 id="2-登录码云并选择创建仓库"><a href="#2-登录码云并选择创建仓库" class="headerlink" title="2.登录码云并选择创建仓库"></a>2.登录码云并选择创建仓库</h2><p><img src="/assets/img/创建仓库.png" alt="创建仓库"></p><h2 id="3-导入仓库"><a href="#3-导入仓库" class="headerlink" title="3.导入仓库"></a>3.导入仓库</h2><p><img src="/assets/img/导入仓库.png" alt="创建仓库"><br>输入对应的仓库地址,完成后选择导入</p><h2 id="4-完成导入"><a href="#4-完成导入" class="headerlink" title="4.完成导入"></a>4.完成导入</h2><p>导入完成后你就可以在你的码云仓库中找到对应的仓库,这个时候再下载就会很快了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;p&gt;我们总是需要在github去下载一些代码,但是因为一些原因,下载的速度忽快忽慢,而一些第三方的网站号称可以代下载,但是也是会很慢,或者直接就下载不下来,这个时候我们就需要用到&lt;a href=&quot;https://gitee.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;码云&lt;/a&gt;来帮助我们下载.接下来我们以CocoaPods为例&lt;/p&gt;
    
    </summary>
    
      <category term="github" scheme="http://LikeeCat.github.io/categories/github/"/>
    
    
      <category term="github" scheme="http://LikeeCat.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 加载txt文件</title>
    <link href="http://LikeeCat.github.io/2019/11/17/%20Flutter%20%E5%8A%A0%E8%BD%BDtxt%E6%96%87%E4%BB%B6/"/>
    <id>http://LikeeCat.github.io/2019/11/17/ Flutter 加载txt文件/</id>
    <published>2019-11-17T10:05:13.000Z</published>
    <updated>2019-11-17T03:22:51.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter-之加载txt文件"><a href="#Flutter-之加载txt文件" class="headerlink" title="Flutter 之加载txt文件"></a>Flutter 之加载txt文件</h2><p>我想要加载工程中的txt文件,网上搜了一圈,没有找到相关的内容,在此做一下脱坑的记录</p><h3 id="1-在工程下新建txt文件"><a href="#1-在工程下新建txt文件" class="headerlink" title="1.在工程下新建txt文件"></a>1.在工程下新建txt文件</h3><p> <img src="/assets/img/flutterpath.png" alt="路径"><br><a id="more"></a></p><h3 id="2-在pubspec-yaml中引用"><a href="#2-在pubspec-yaml中引用" class="headerlink" title="2.在pubspec.yaml中引用"></a>2.在pubspec.yaml中引用</h3><p>  assets:<br>        -data/agreeText.txt</p><h3 id="3-在dart文件中使用"><a href="#3-在dart文件中使用" class="headerlink" title="3.在dart文件中使用"></a>3.在dart文件中使用</h3><h4 id="引入头文件-并复制这个方法"><a href="#引入头文件-并复制这个方法" class="headerlink" title="引入头文件,并复制这个方法"></a>引入头文件,并复制这个方法</h4><p>import ‘package:flutter/services.dart’ show rootBundle;</p><p>Future<string> loadAsset() async {<br>  var a = await rootBundle.loadString(‘data/agreeText.txt’);<br>  return a;<br>}</string></p><h4 id="在widget中使用"><a href="#在widget中使用" class="headerlink" title="在widget中使用"></a>在widget中使用</h4><p>因为是异步函数,所以需要结合setseate来使用</p><pre><code> var _result = &quot;&quot;; dynamic result; void loadAssests() async { result = await loadAsset(); print(result); setState(() {   _result = result.toString();     });   }@overridevoid initState() { loadAssests();}@overrideWidget build(BuildContext context) {return new MaterialApp(  title: &apos;Welcome to Flutter&apos;,  home: new Scaffold(    appBar: new AppBar(      title: new Text(&apos;Welcome to Flutter&apos;),    ),    body: new Center(      child: new Text(_result),    ),  ),);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flutter-之加载txt文件&quot;&gt;&lt;a href=&quot;#Flutter-之加载txt文件&quot; class=&quot;headerlink&quot; title=&quot;Flutter 之加载txt文件&quot;&gt;&lt;/a&gt;Flutter 之加载txt文件&lt;/h2&gt;&lt;p&gt;我想要加载工程中的txt文件,网上搜了一圈,没有找到相关的内容,在此做一下脱坑的记录&lt;/p&gt;
&lt;h3 id=&quot;1-在工程下新建txt文件&quot;&gt;&lt;a href=&quot;#1-在工程下新建txt文件&quot; class=&quot;headerlink&quot; title=&quot;1.在工程下新建txt文件&quot;&gt;&lt;/a&gt;1.在工程下新建txt文件&lt;/h3&gt;&lt;p&gt; &lt;img src=&quot;/assets/img/flutterpath.png&quot; alt=&quot;路径&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://LikeeCat.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://LikeeCat.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>面试问题汇总</title>
    <link href="http://LikeeCat.github.io/2019/06/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://LikeeCat.github.io/2019/06/12/面试问题汇总/</id>
    <published>2019-06-12T10:05:13.000Z</published>
    <updated>2019-07-20T05:16:25.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于离屏渲染的问题"><a href="#关于离屏渲染的问题" class="headerlink" title="关于离屏渲染的问题"></a>关于离屏渲染的问题</h2><ol><li><p>什么是mask</p><blockquote><p>一个图层可以有一个和它相关的mask(蒙版),mask是一个拥有alpha的位图,当像素和它下面的像素合成之前都会把mask应用到图层的像素上面,当你要设置一个图层的圆角半径的时候,你可以有效的在图层上设置一个mask,最终只有mask中显示出来的部分才会被渲染出来</p><a id="more"></a></blockquote></li><li><p>设置圆角的时候是什么触发了离屏渲染,为什么会触发离屏渲染</p><blockquote><p>是因为mask,layer的圆角将mask应用到一个图层上,core Animation为了应用这个mask,会强制进行屏幕外的渲染.这对GPU产生重负.</p></blockquote></li><li>离屏渲染为什么消耗性能<blockquote><p>离屏渲染合成计算是非常昂贵的,直接将图层合成到桢的缓冲区(在屏幕上),比先创建在屏幕外的缓冲区,然后渲染到纹理中,最后将结果渲染到桢的缓冲区中要廉价的多.因为其中涉及到了两次昂贵的环境切换(转换环境到屏幕外缓冲区,再转换环境到帧缓冲区).<br>为 layer 使用mask或者设置圆角半径(特殊的mask)会造成屏幕外渲染，产生阴影也会如此。</p></blockquote></li></ol><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><ol><li><p>block使用weakSelf关键字的时候有什么坏处</p><blockquote><p>有可能在你使用block的时候,这个对象就已经被销毁了</p></blockquote></li><li><p>使用weakSelf后,如何避免对象已经被销毁</p><blockquote><p>使用strongSelf来保证在block的执行过程中这个变量不被释放</p></blockquote></li><li><p>什么是weakSelf</p><blockquote><p>weakSelf 是为了block不持有self，避免Retain Circle循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf</p></blockquote></li><li><p>什么是strongSelf</p><blockquote><p>strongSelf的目的是因为一旦进入block执行，假设不允许self在这个执行过程中释放，就需要加入strongSelf。block执行完后这个strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf</p></blockquote></li></ol><h2 id="static-const"><a href="#static-const" class="headerlink" title="static const"></a>static const</h2><ol><li><p>什么是extern</p><blockquote><p>extern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定</p></blockquote></li><li><p>如何使用</p><pre><code>//xxx.hextern NSString *const EocStringConstant;//xxx.mNSString *const EocStringConstant = @&quot;VALUE&quot;</code></pre></li><li>为什么使用常量的时候要使用const,而不是宏<blockquote><p>1.编译时刻:宏是预编译（编译之前处理），const是编译阶段。<br> 2.编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。<br> 3.宏的好处:宏能定义一些函数，方法。 const不能。<br> 4.宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。    </p></blockquote></li></ol><h2 id="lldb命令"><a href="#lldb命令" class="headerlink" title="lldb命令"></a>lldb命令</h2><ol><li>p 和 po 的区别</li></ol><blockquote><pre><code>p  -- Evaluate an expression on the current thread.  Displays any           returned value with LLDB&apos;s default formatting.          使用的是lldb中默认的formatting</code></pre></blockquote><blockquote><p>po        – Evaluate an expression on the current thread.  Displays any<br>               returned value with formatting controlled by the type’s author.<br>               使用的formatter  是lldb中由类型的作者自己控制的(重写对象的description方法)</p></blockquote><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ol><li><p>nsarray 的 mutablecopy 是深拷贝还是浅拷贝<br>是深拷贝,它在堆上开辟了一块新的内存空间</p></li><li><p>深拷贝是什么<br>不只是拷贝指针,并且拷贝了值</p></li><li><p>浅拷贝是什么<br>是拷贝指针,一旦改变,连同拷贝前的也会发生改变</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于离屏渲染的问题&quot;&gt;&lt;a href=&quot;#关于离屏渲染的问题&quot; class=&quot;headerlink&quot; title=&quot;关于离屏渲染的问题&quot;&gt;&lt;/a&gt;关于离屏渲染的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是mask&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个图层可以有一个和它相关的mask(蒙版),mask是一个拥有alpha的位图,当像素和它下面的像素合成之前都会把mask应用到图层的像素上面,当你要设置一个图层的圆角半径的时候,你可以有效的在图层上设置一个mask,最终只有mask中显示出来的部分才会被渲染出来&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://LikeeCat.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://LikeeCat.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>NSArray之深浅拷贝</title>
    <link href="http://LikeeCat.github.io/2019/06/11/NSArray%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://LikeeCat.github.io/2019/06/11/NSArray之深浅拷贝/</id>
    <published>2019-06-11T10:05:13.000Z</published>
    <updated>2019-07-20T05:15:54.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义对象"><a href="#1-自定义对象" class="headerlink" title="1. 自定义对象"></a>1. 自定义对象</h2><ol><li><p>假设我有一个Student类</p><pre><code>@interface Student()&lt;NSCopying,NSMutableCopying&gt;@property (nonatomic,copy)NSString *name;@property (nonatomic,assign)NSInteger age;@end</code></pre> <a id="more"></a></li><li><p>生成两个Student对象</p><pre><code> Student *stu = [[Student alloc]initWithName:@&quot;a&quot; age:1];Student *stu1 = [[Student alloc]initWithName:@&quot;b&quot; age:2];</code></pre></li><li><p>用NSArray去把这两个对象加进数组,分别对数组进行copy 和 mutableCopy</p><pre><code>NSArray *arr = [NSArray arrayWithObjects:stu,stu1, nil];NSArray *arrCopy =  [arr copy] ;NSMutableArray *arrMuCopy = [arr mutableCopy];</code></pre></li><li><p>在arrMuCopy之后打断点查看结果</p><pre><code> po arr&lt;__NSArrayI 0x102900290&gt;(&lt;Student: 0x100646bc0&gt;,&lt;Student: 0x100647300&gt;) po arrCopy&lt;__NSArrayI 0x102900290&gt;(&lt;Student: 0x100646bc0&gt;,&lt;Student: 0x100647300&gt;)po arrMuCopy&lt;__NSArrayM 0x1029056f0&gt;(&lt;Student: 0x100646bc0&gt;,&lt;Student: 0x100647300&gt;)</code></pre><blockquote><p>从结果上来说,copy只是复制了一个指针,arr 和 arrCopy 在堆上的对象是同一个.而arrMuCopy则是创建了新的内存地址,即创建了一个新的NSMutableArray的对象,但是array中包含的自定义对象没有复制.</p></blockquote></li><li><p>重写Student的description方法</p><pre><code>-(NSString *)description{ return [NSString stringWithFormat:@&quot;name:%@\n age :%d&quot;,self.name,self.age]; }</code></pre></li><li><p>在copy 和 mutableCopy 结束后打断点</p><pre><code>  NSArray *arr = [NSArray arrayWithObjects:stu,stu1, nil];NSArray *arrCopy =  [arr copy] ;NSMutableArray *arrMuCopy = [arr mutableCopy];[stu changeName:@&quot;ccc&quot;]; po arr&lt;__NSArrayI 0x1029002c0&gt;(name:ccc age :1,name:b age :2) po arrCopy&lt;__NSArrayI 0x1029002c0&gt;(name:ccc age :1,name:b age :2)po arrMuCopy&lt;__NSArrayM 0x102909590&gt;(name:ccc age :1,name:b age :2)</code></pre></li></ol><p>结果也论证了这一点,mutableCopy后并没有将array中的对象进行复制</p><h2 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h2><ol><li><p>用NSArray去把这两个对象加进数组,分别对数组进行copy 和 mutableCopy</p><pre><code>NSArray *arr = [NSArray arrayWithObjects:@&quot;aaa&quot;,@&quot;bbb&quot;, nil];NSArray *arrCopy =  [arr copy] ;NSMutableArray *arrMuCopy = [arr mutableCopy];</code></pre></li><li><p>在copy 和 mutableCopy 结束后打断点</p><pre><code>po arr&lt;__NSArrayI 0x100504700&gt;(aaa,bbb)po arrCopy&lt;__NSArrayI 0x100504700&gt;(aaa,bbb)po arrMuCopy&lt;__NSArrayM 0x100503290&gt;(aaa,bbb) p arr[0](__NSCFConstantString *) $4 = 0x00000001000020d0 @&quot;aaa&quot;p arrCopy[0](__NSCFConstantString *) $7 = 0x00000001000020d0 @&quot;aaa&quot;p arrMuCopy[0](__NSCFConstantString *) $6 = 0x00000001000020d0 @&quot;aaa&quot;</code></pre></li></ol><p>结果也论证了这一点,mutableCopy后并没有将array中的对象进行复制</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-自定义对象&quot;&gt;&lt;a href=&quot;#1-自定义对象&quot; class=&quot;headerlink&quot; title=&quot;1. 自定义对象&quot;&gt;&lt;/a&gt;1. 自定义对象&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设我有一个Student类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface Student()&amp;lt;NSCopying,NSMutableCopying&amp;gt;
@property (nonatomic,copy)NSString *name;
@property (nonatomic,assign)NSInteger age;
@end
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/categories/NSArray/"/>
    
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/tags/NSArray/"/>
    
  </entry>
  
  <entry>
    <title>Xcode快捷键</title>
    <link href="http://LikeeCat.github.io/2019/05/30/Xcode%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"/>
    <id>http://LikeeCat.github.io/2019/05/30/Xcode 快捷操作/</id>
    <published>2019-05-30T01:05:58.000Z</published>
    <updated>2019-07-20T05:15:34.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编辑的快捷键"><a href="#编辑的快捷键" class="headerlink" title="编辑的快捷键"></a>编辑的快捷键</h2><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>command + ↑</td><td>到达文件头部</td></tr><tr><td>command +  ↓</td><td>到达文件尾部</td></tr><tr><td>command + [</td><td>向左移动代码</td></tr><tr><td>command + ]</td><td>向右移动代码</td></tr><tr><td>option + command + [</td><td>向上移动代码</td></tr><tr><td>option + command + ]</td><td>向下移动代码</td></tr><tr><td>command + /</td><td>快速注释或者取消注释</td></tr><tr><td>Ctrl + A</td><td>移动光标到本行行首 </td></tr><tr><td>Ctrl + E</td><td>移动光标到本行行尾 </td></tr><tr><td>option + →</td><td>移动光标到下一个单词</td></tr><tr><td>option +  ←</td><td>移动光标到上一个单词</td></tr></tbody></table><a id="more"></a><h2 id="视图快捷键"><a href="#视图快捷键" class="headerlink" title="视图快捷键"></a>视图快捷键</h2><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>shift + command  + y</td><td>隐藏/打开控制台</td></tr><tr><td>Ctrl + command + ↑↓</td><td>快速切换.h和.m文件</td></tr><tr><td>Ctrl + command + → ←</td><td>打开下一个/上一个文件</td></tr></tbody></table><h2 id="搜索快捷键"><a href="#搜索快捷键" class="headerlink" title="搜索快捷键"></a>搜索快捷键</h2><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>command  + f</td><td>在当前文件搜索</td></tr><tr><td>shift + command + f</td><td>打开全局搜索</td></tr><tr><td>command  + g</td><td>跳到下一个搜索结果</td></tr><tr><td>shift +command  + g</td><td>跳到上一个搜索结果</td></tr><tr><td>shift +command  + o</td><td>快速打开一个文件</td></tr></tbody></table><h1 id="编译快捷键"><a href="#编译快捷键" class="headerlink" title="编译快捷键"></a>编译快捷键</h1><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>command  + r</td><td>运行</td></tr><tr><td>command  + b</td><td>编译</td></tr><tr><td>shift + command  + k</td><td>清除工程</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编辑的快捷键&quot;&gt;&lt;a href=&quot;#编辑的快捷键&quot; class=&quot;headerlink&quot; title=&quot;编辑的快捷键&quot;&gt;&lt;/a&gt;编辑的快捷键&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;command + ↑&lt;/td&gt;
&lt;td&gt;到达文件头部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command +  ↓&lt;/td&gt;
&lt;td&gt;到达文件尾部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command + [&lt;/td&gt;
&lt;td&gt;向左移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command + ]&lt;/td&gt;
&lt;td&gt;向右移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option + command + [&lt;/td&gt;
&lt;td&gt;向上移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option + command + ]&lt;/td&gt;
&lt;td&gt;向下移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command + /&lt;/td&gt;
&lt;td&gt;快速注释或者取消注释&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + A&lt;/td&gt;
&lt;td&gt;移动光标到本行行首 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + E&lt;/td&gt;
&lt;td&gt;移动光标到本行行尾 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option + →&lt;/td&gt;
&lt;td&gt;移动光标到下一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option +  ←&lt;/td&gt;
&lt;td&gt;移动光标到上一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="tip" scheme="http://LikeeCat.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://LikeeCat.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中文排序</title>
    <link href="http://LikeeCat.github.io/2019/05/29/iOS%E4%B8%AD%E6%96%87%E6%8E%92%E5%BA%8F/"/>
    <id>http://LikeeCat.github.io/2019/05/29/iOS中文排序/</id>
    <published>2019-05-29T11:05:58.000Z</published>
    <updated>2019-07-20T05:15:24.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h1><h2 id="localizedCompare"><a href="#localizedCompare" class="headerlink" title="localizedCompare(_:)"></a>localizedCompare(_:)</h2><p>Compares the string and a given string using a localized comparison.</p><blockquote><p>在NSString 的 API 中有这个方法,假设你的手机使用的是中文,就可以根据中文排序</p></blockquote><a id="more"></a><h2 id="NSSortDescriptor"><a href="#NSSortDescriptor" class="headerlink" title="NSSortDescriptor"></a>NSSortDescriptor</h2><p>An immutable description of how to order a collection of objects based on a property common to all the objects.</p><blockquote><p>可以根据集合中的对象的某一个属性对这个集合进行排序</p></blockquote><h2 id="initWithKey-ascending-selector"><a href="#initWithKey-ascending-selector" class="headerlink" title="initWithKey:ascending:selector:"></a>initWithKey:ascending:selector:</h2><pre><code>- (instancetype)initWithKey:(NSString *)key               ascending:(BOOL)ascending                selector:(SEL)selector;根据给出的key 升序还是降序 还有使用selector来初始化</code></pre><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><pre><code>@interface person : NSObject@property (nonatomic,strong)NSString *name;@property (nonatomic,strong)NSString *phone;@end</code></pre><h2 id="定义对象的集合"><a href="#定义对象的集合" class="headerlink" title="定义对象的集合"></a>定义对象的集合</h2><pre><code>person *p = [[person alloc]initWithName:@&quot;小小&quot; phone:@&quot;13322223333&quot;];person *p1 = [[person alloc]initWithName:@&quot;小二&quot; phone:@&quot;13322223333&quot;];person *p2 = [[person alloc]initWithName:@&quot;校小&quot; phone:@&quot;13322223333&quot;];NSMutableArray *arr  = [NSMutableArray arrayWithArray:@[p,p1,p2]];</code></pre><h2 id="定义排序方法"><a href="#定义排序方法" class="headerlink" title="定义排序方法"></a>定义排序方法</h2><pre><code>NSArray *sortDescriptors = [NSArray arrayWithObject:[NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES selector:@selector(localizedCompare:)]];</code></pre><h2 id="进行排序"><a href="#进行排序" class="headerlink" title="进行排序"></a>进行排序</h2><pre><code>[arr sortUsingDescriptors:sortDescriptors];</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序方法&quot;&gt;&lt;a href=&quot;#排序方法&quot; class=&quot;headerlink&quot; title=&quot;排序方法&quot;&gt;&lt;/a&gt;排序方法&lt;/h1&gt;&lt;h2 id=&quot;localizedCompare&quot;&gt;&lt;a href=&quot;#localizedCompare&quot; class=&quot;headerlink&quot; title=&quot;localizedCompare(_:)&quot;&gt;&lt;/a&gt;localizedCompare(_:)&lt;/h2&gt;&lt;p&gt;Compares the string and a given string using a localized comparison.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在NSString 的 API 中有这个方法,假设你的手机使用的是中文,就可以根据中文排序&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tip" scheme="http://LikeeCat.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://LikeeCat.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>OC中函数的一些小技巧</title>
    <link href="http://LikeeCat.github.io/2019/04/16/OC%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://LikeeCat.github.io/2019/04/16/OC中函数的一些理解/</id>
    <published>2019-04-16T03:18:13.000Z</published>
    <updated>2019-06-12T06:57:48.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在做一个复杂的界面，涉及到 UINavigationController 、UITabBarController、UIViewController、之间的函数调用，需要把原先在UIViewController中的功能转移到UITabBarController 或者 UINavigationController中，这就导致了界面产生冲突，我已经在UIViewController中完成了这个方法，怎么在UINavigationController中调用</p><a id="more"></a><h2 id="关于objc-msgSend"><a href="#关于objc-msgSend" class="headerlink" title="关于objc_msgSend"></a>关于objc_msgSend</h2><p>在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说叫做传递消息。消息有名称 (name) 或选择子 (selector) ,可以接受参数，并且还有可能有返回值。   </p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>类的方法列表会把selector的名称的映射到相对应的方法上，使得“动态消息派发系统”能够据此找到相应的方法。这些方法均以函数指针的形式来表示，这种指针就是IMP</p><pre><code>id (*IMP) = (id,SEL,...) </code></pre><h3 id="selector-SEL-的生成"><a href="#selector-SEL-的生成" class="headerlink" title="selector(SEL)的生成"></a>selector(SEL)的生成</h3><p>SEL的生成分为三种情况<br>1.无参</p><pre><code>SEL selector = NSSelectorFromString(@&quot;log&quot;);</code></pre><p>2.有参数</p><pre><code>SEL selector = NSSelectorFromString(@&quot;logWithAll:type:&quot;);</code></pre><h3 id="IMP的生成"><a href="#IMP的生成" class="headerlink" title="IMP的生成"></a>IMP的生成</h3><pre><code>IMP imp1 = [self methodForSelector:selector];</code></pre><h3 id="方法的执行"><a href="#方法的执行" class="headerlink" title="方法的执行"></a>方法的执行</h3><pre><code>- (NSString *)logWithAll:(NSString *)name type:(NSString *)type{    NSLog(@&quot;name is %@  type is %@&quot;,name,type);    return @&quot;aaa&quot;;}if ([self respondsToSelector:selector]) {    NSString* (*func)(id,SEL,NSString*,NSString*) = (void *)imp1;    NSString *result =  func(self,selector,@&quot;哈哈&quot;,@&quot;hehe&quot;);    NSLog(@&quot;result is %@&quot;,result);}</code></pre><p>##结果<br>结构大概就是这样的</p><pre><code>NSString* (*func)(id,SEL,NSString*,NSString*) = (void *)imp1;返回值                     parmar1  parmar2       IMP</code></pre><p>调用</p><pre><code>NSString *result =  func(self,selector,@&quot;哈哈&quot;,@&quot;hehe&quot;);</code></pre><p>输出结果</p><p><img src="/assets/img/oc函数.png" alt="结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在做一个复杂的界面，涉及到 UINavigationController 、UITabBarController、UIViewController、之间的函数调用，需要把原先在UIViewController中的功能转移到UITabBarController 或者 UINavigationController中，这就导致了界面产生冲突，我已经在UIViewController中完成了这个方法，怎么在UINavigationController中调用&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://LikeeCat.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://LikeeCat.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>把博客从简书搬出来</title>
    <link href="http://LikeeCat.github.io/2019/03/16/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E4%BB%8E%E7%AE%80%E4%B9%A6%E6%90%AC%E5%87%BA%E6%9D%A5/"/>
    <id>http://LikeeCat.github.io/2019/03/16/把博客从简书搬出来/</id>
    <published>2019-03-16T11:05:58.000Z</published>
    <updated>2019-05-30T02:43:05.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起"><a href="#起" class="headerlink" title="起"></a>起</h1><p>忽然觉得大多数的写作的地方都太浮躁了，自己想找个安静的角落，写一写关于技术、生活、旅游方面的姑且认为是文章啦，于是就有了想自己做一个静态网站的想法。</p><h1 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h1><p>花了一周的时间想了很久，最终还是在 GitHub 上安家了，离开自己的舒服区，跑来折腾前端的我也是有够拼的。接下来就慢慢的写，让自己能够得到一些沉淀吧。折腾了一天的我，突然发现天也已经暗了下来，不过总算是完成了一大半的工程。<br><a id="more"></a></p><h1 id="终"><a href="#终" class="headerlink" title="终"></a>终</h1><p>这应该就是我的桃花源吧。<br>晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林<br><img src="/assets/img/搬家.png" alt="桃花源"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起&quot;&gt;&lt;a href=&quot;#起&quot; class=&quot;headerlink&quot; title=&quot;起&quot;&gt;&lt;/a&gt;起&lt;/h1&gt;&lt;p&gt;忽然觉得大多数的写作的地方都太浮躁了，自己想找个安静的角落，写一写关于技术、生活、旅游方面的姑且认为是文章啦，于是就有了想自己做一个静态网站的想法。&lt;/p&gt;
&lt;h1 id=&quot;接下来&quot;&gt;&lt;a href=&quot;#接下来&quot; class=&quot;headerlink&quot; title=&quot;接下来&quot;&gt;&lt;/a&gt;接下来&lt;/h1&gt;&lt;p&gt;花了一周的时间想了很久，最终还是在 GitHub 上安家了，离开自己的舒服区，跑来折腾前端的我也是有够拼的。接下来就慢慢的写，让自己能够得到一些沉淀吧。折腾了一天的我，突然发现天也已经暗了下来，不过总算是完成了一大半的工程。&lt;br&gt;
    
    </summary>
    
      <category term="日记" scheme="http://LikeeCat.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://LikeeCat.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中 CSV格式文件读写</title>
    <link href="http://LikeeCat.github.io/2019/03/16/iOS-%E4%B8%AD-CSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://LikeeCat.github.io/2019/03/16/iOS-中-CSV格式文件读写/</id>
    <published>2019-03-16T09:09:15.000Z</published>
    <updated>2019-06-12T06:56:19.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h1><p><strong>逗号分隔值</strong>（Comma-Separated Values，<strong>CSV</strong>，有时也称为<strong>字符分隔值</strong>，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本)。（:来自百度百科）</p><blockquote><p>CSV其实就是一个<strong>纯文本</strong>,那么对应到 Objective-C 中，他就是一个<code>NSString</code>,对应到 Swift 中就是一个<code>String</code></p></blockquote><a id="more"></a><h1 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h1><blockquote><p>sj_mino1001.jpg,715282,4FB55FE8<br>sj_mino1002.jpg,471289,93203C5C<br>sj_mino1003.jpg,451929,C4E80467<br>这个就是一个简单的CSV文件,每个值之间用,分割,在一行数据结束的时候才换行。</p></blockquote><h1 id="CSV读取"><a href="#CSV读取" class="headerlink" title="CSV读取"></a>CSV读取</h1><p>假设我们的项目中有一个 csv 文件，叫做1</p><p>1.获取文件路径</p><pre><code>NSString  *path = [[NSBundle mainBundle]pathForResource:@&quot;1&quot; ofType:@&quot;csv&quot;];</code></pre><p>2.将此文件转码为一个字符串</p><pre><code>NSError *error = nil;//GBK编码NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:0x80000632 error:&amp;error];//UTF8编码NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error];</code></pre><p>3.切割字符串，可以拿到每一行的数据</p><pre><code>//取出每一行的数据NSArray *_allLinedStrings = [fileContents componentsSeparatedByString:@&quot;\r\n&quot;];</code></pre><p>4.如果有表头可以对表头进行处理，即对第一行数据进行处理</p><pre><code>__block NSInteger nameRow = 0;__block NSInteger phoneRow = 0;NSArray *firstLine = [_allLinedStrings[0] componentsSeparatedByString:@&quot;,&quot;];[firstLine enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {NSString *line = obj;if ([line isEqualToString:@&quot;客户名称&quot;]){    nameRow = idx;}else if ([line isEqualToString:@&quot;手机号&quot;]){    phoneRow = idx;}}];</code></pre><p>5.对数据进行处理</p><pre><code>[_allLinedStrings enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    if (idx == 0) {    }    else{      NSString *str = obj;        NSArray *array = [str componentsSeparatedByString:@&quot;,&quot;];       //获取到某一行的数据，切割这个字符串就可以拿到这一行的值，然后在进行下一步的处理    }     }];</code></pre><h1 id="CSV文件的写入"><a href="#CSV文件的写入" class="headerlink" title="CSV文件的写入"></a>CSV文件的写入</h1><p>假设我们有一个 likee.csv 需要放在Documents目录下</p><p>1.创建写入路径</p><pre><code>NSString *fileNameStr = @&quot;likee.Csv&quot;;NSString *DocPath = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:fileNameStr];</code></pre><p>2.够造需要写入的数据</p><pre><code>NSString *str = @&quot;11111,22222,33333,44444\n&quot;;NSMutableString *csvString = [NSMutableString string];for (int i = 0; i&lt; 400; i ++) { [csvString appendString:str]; };</code></pre><p>3.够造为NSData，并使用NSData进行文件的写入。</p><pre><code>NSData *data = [csvString dataUsingEncoding:NSUTF8StringEncoding];[data writeToFile:DocPath atomically:YES];</code></pre><h1 id="编码格式的坑"><a href="#编码格式的坑" class="headerlink" title="编码格式的坑"></a>编码格式的坑</h1><p>在 mac 下文本的默认编码格式使用的是UTF-8，在 windows 的 Excel 上，对中文的处理是GBK,所以可能会造成乱码的问题。如果读取文件是无法读出内容，就和使用的编码格式有关。所以建议先使用UTF-8进行解码，如果无法显示内容，再用GBK进行解码</p><pre><code> //UTF8编码NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error];if(!fileContents){    //GBK编码    fileContents = [NSString stringWithContentsOfFile:path encoding:0x80000632 error:&amp;error];}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSV&quot;&gt;&lt;a href=&quot;#CSV&quot; class=&quot;headerlink&quot; title=&quot;CSV&quot;&gt;&lt;/a&gt;CSV&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;逗号分隔值&lt;/strong&gt;（Comma-Separated Values，&lt;strong&gt;CSV&lt;/strong&gt;，有时也称为&lt;strong&gt;字符分隔值&lt;/strong&gt;，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本)。（:来自百度百科）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSV其实就是一个&lt;strong&gt;纯文本&lt;/strong&gt;,那么对应到 Objective-C 中，他就是一个&lt;code&gt;NSString&lt;/code&gt;,对应到 Swift 中就是一个&lt;code&gt;String&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://LikeeCat.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://LikeeCat.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSArray 之 SEL 的保存</title>
    <link href="http://LikeeCat.github.io/2019/02/27/NSArray%20%E4%B9%8B%20SEL%20%E7%9A%84%E4%BF%9D%E5%AD%98/"/>
    <id>http://LikeeCat.github.io/2019/02/27/NSArray 之 SEL 的保存/</id>
    <published>2019-02-27T10:05:13.000Z</published>
    <updated>2019-06-12T06:56:17.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近在初始化类的时候，会有很多没有返回值的初始化方法需要调用，每次都需要再写一遍，所以想把函数装进 NSArray 中可以自动调用。结果查了一下真的可以，所以做个笔记记一下</p><a id="more"></a><pre><code>- (void)viewDidLoad {    [super viewDidLoad];    NSString* A = NSStringFromSelector(@selector(loadA));    NSString* B = NSStringFromSelector(@selector(loadB));    NSString* C = NSStringFromSelector(@selector(loadC));    NSArray *arr = @[A,B,C];    [arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {        NSString *selector = obj;        if (!self) { return; }        SEL performSelector = NSSelectorFromString(selector);        if ([self respondsToSelector:performSelector]){            [self performSelector:performSelector];        }    }];}- (void)loadA{    NSLog(@&quot;call load A +++++++&quot;);}- (void)loadB{    NSLog(@&quot;call load B ++++++++&quot;);}- (void)loadC{    NSLog(@&quot;call load C +++++&quot;);}</code></pre><p>然后就写了一个小 demo,写完后报了警告，查过<a href="https://www.jianshu.com/p/6517ab655be7" target="_blank" rel="noopener">爆栈热门 iOS 问题</a>后，解决了这个问题。<br><img src="https://upload-images.jianshu.io/upload_images/2239937-b6801e1b52041ae2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>NSString* A = NSStringFromSelector(@selector(loadA));NSString* B = NSStringFromSelector(@selector(loadB));NSString* C = NSStringFromSelector(@selector(loadC));NSArray *arr = @[A,B,C];[arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    NSString *selector = obj;    if (!self) { return; }    SEL performSelector = NSSelectorFromString(selector);    IMP imp = [self methodForSelector:performSelector];    void (*func)(id, SEL) = (void *)imp;    func(self, performSelector);}];</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;最近在初始化类的时候，会有很多没有返回值的初始化方法需要调用，每次都需要再写一遍，所以想把函数装进 NSArray 中可以自动调用。结果查了一下真的可以，所以做个笔记记一下&lt;/p&gt;
    
    </summary>
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/categories/NSArray/"/>
    
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/tags/NSArray/"/>
    
  </entry>
  
  <entry>
    <title>UITableView reloadData 滑不到底部</title>
    <link href="http://LikeeCat.github.io/2019/02/18/UITableView%20reloadData%20%E6%BB%91%E4%B8%8D%E5%88%B0%E5%BA%95%E9%83%A8/"/>
    <id>http://LikeeCat.github.io/2019/02/18/UITableView reloadData 滑不到底部/</id>
    <published>2019-02-18T10:05:13.000Z</published>
    <updated>2019-05-29T04:38:01.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近有个需求，在 tableView <code>reloadData</code>结束后，需要滑动到底部，可是总是不能准确的滚动到底部。自然而言的就想到了三个方法，查看了一下有关的文档</p><ol><li>layoutSubviews</li><li>setNeedsLayout</li><li>layoutIfNeeded</li></ol><a id="more"></a><h3 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h3><p>Lays out subviews.</p><h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p><p>You should not call this method directly. If you want to force a layout update, call the <code>setNeedsLayout</code> method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the <code>layoutIfNeeded</code> method.</p><p>在子类中，如果你需要更加准确的定位，你可以重写这个方法。如果 autoresizing 和 constraint不能为你提供你想要做的。你可以自己设置subviews的 frame。<br>你不应该直接调用这个方法，如果你想要强制更新布局，应该调用<code>setNeedsLayout</code>,在下一次绘图更新之前，如果你想要立刻的更新布局，需要调用 <code>layoutIfNeeded</code></p><h3 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h3><p>Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.</p><h4 id="Discussion-1"><a href="#Discussion-1" class="headerlink" title="Discussion"></a>Discussion</h4><p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.<br>你在想要更新 view 的 subviews 的布局的时候，可以在主线程调用此方法。此方法记录请求并且立即返回。因为这个方法不强制立即更新，而是等待下一个周期更新，你可以使用此方法来让很多 views 的布局失效，并且这样做可以把所有布局更新合并到一个更新周期，这通常会提高性能。</p><h3 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h3><p>Lays out the subviews immediately, if layout updates are pending.</p><h4 id="Discussion-2"><a href="#Discussion-2" class="headerlink" title="Discussion"></a>Discussion</h4><p>Use this method to force the view to update its layout immediately. When using Auto Layout, the layout engine updates the position of views as needed to satisfy changes in constraints. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root. If no layout updates are pending, this method exits without modifying the layout or calling any layout-related callbacks.<br>使用此方法强制视图立即更新其布局。使用“自动布局”时，布局引擎会根据需要更新视图的位置，以满足约束的更改，使用一个 view 作为 rootView ，此方法从根开始布局视图子树。如果没有约束需要更新，此方法会退出，不会修改 layout 或者调用和此 layout 有关的回调。</p><h2 id="stackoverflow上的提问"><a href="#stackoverflow上的提问" class="headerlink" title="stackoverflow上的提问"></a>stackoverflow上的提问</h2><p>在 stackoverflow上有查到一个问题， <a href="https://stackoverflow.com/questions/16071503/how-to-tell-when-uitableview-has-completed-reloaddata" target="_blank" rel="noopener">How to tell when UITableView has completed ReloadData?</a>，提问的人想要滚动 tableView 到底部，发现调用直接 reloadData，然后滚动没有滚动到最底部，提出了这个问题。 这个下面有很多很多的答案，具体的如下：<br>1.调用<code>layoutIfNeeded</code>强制的刷新布局，接着执行scrollToRowAtIndexPath,滚动到底部，确实是帮助我们解决了这个问题。</p><pre><code>[self.tableView reloadData];[self.tableView layoutIfNeeded];NSIndexPath* indexPath = [NSIndexPath indexPathForRow: ([self.tableView numberOfRowsInSection:([self.tableView     numberOfSections]-1)]-1) inSection: ([self.tableView numberOfSections]-1)];[self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES];</code></pre><p>原因：</p><blockquote><p>The reload happens during the next layout pass, which normally happens when you return control to the run loop (after, say, your button action or whatever returns).<br>So one way to run something after the table view reloads is simply to force the table view to perform layout immediately<br>重新加载发生在下一个布局过程中，这通常发生在将控制返回到运行循环时（例如，您的按钮操作或任何返回之后）。<br>所以，在tableView reloads 后可以立刻强制更新布局。</p></blockquote><ol start="2"><li><p>调用<code>dispatch_async(dispatch_get_main_queue(), ^{})</code></p><pre><code>[self.tableView reloadData]; dispatch_async(dispatch_get_main_queue(), ^{ NSIndexPath* indexPath = [NSIndexPath indexPathForRow: ([self.tableView numberOfRowsInSection:([self.tableView numberOfSections]-1)]-1) inSection:([self.tableView numberOfSections]-1)]; [self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; });</code></pre><p>原因</p></li></ol><blockquote><p>depending on how big your table data source is, you can animate going to the bottom of the tableview in the same run loop. If you try your test code with a huge table, your trick of using GCD to delay scrolling until the next run loop will work, whereas immediately scrolling will fail. But anyways, thanks for this trick!<br>但是这种方式并不总是能解决问题,使用GCD来延迟滑动到下一个 runloop，但是立即滑动的话，就会出错。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的 tableView 在 <code>reloadData</code>后，无法滑动到底部，那么就可以这样做,在<code>reloadData</code>后，调用 <code>layoutIfNeeded</code>，来强制进行布局，然后在进行 tableView的滑动就可以了。</p><pre><code>[self.tableView reloadData];[self.tableView layoutIfNeeded];//do somthing you want</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;最近有个需求，在 tableView &lt;code&gt;reloadData&lt;/code&gt;结束后，需要滑动到底部，可是总是不能准确的滚动到底部。自然而言的就想到了三个方法，查看了一下有关的文档&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;layoutSubviews&lt;/li&gt;
&lt;li&gt;setNeedsLayout&lt;/li&gt;
&lt;li&gt;layoutIfNeeded&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="UITableView" scheme="http://LikeeCat.github.io/categories/UITableView/"/>
    
    
      <category term="UITableView" scheme="http://LikeeCat.github.io/tags/UITableView/"/>
    
  </entry>
  
</feed>
