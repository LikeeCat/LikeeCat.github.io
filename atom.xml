<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LikeeCat&#39;s Blog</title>
  
  <subtitle>音乐 | 摄影 | 游戏 | 努力努力再努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LikeeCat.github.io/"/>
  <updated>2020-12-13T09:27:16.355Z</updated>
  <id>http://LikeeCat.github.io/</id>
  
  <author>
    <name>LikeeCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="http://LikeeCat.github.io/2020/12/13/206.%20Reverse%20Linked%20List/"/>
    <id>http://LikeeCat.github.io/2020/12/13/206. Reverse Linked List/</id>
    <published>2020-12-13T09:05:13.000Z</published>
    <updated>2020-12-13T09:27:16.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/206题目.png" alt="题目"></p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从给出的内容来看,考的链表的一些知识,但是这个后进先出的结构特性,让我想起来了stack</li><li>如果节点不为空,就把节点压入栈中,最后,将节点之间按照数组的先后顺序进行连接</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     public var val: Int *     public var next: ListNode? *     public init() { self.val = 0; self.next = nil; } *     public init(_ val: Int) { self.val = val; self.next = nil; } *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; } * } */class Solution {  var stack :[ListNode] = [];  func reverseList(_ head: ListNode?) -&gt; ListNode? {      var tmp = head      //一直将所有的node压入栈,直到node没有下一个node      while  tmp != nil{          stack.insert(tmp!, at: 0)          tmp = tmp?.next      }      //开始将各个node按照数组的先后顺序进行连接    for i in stride(from: 0, through: stack.count - 1, by: 1) {        let node = stack[i]        if(i == stack.count - 1){            node.next = nil;        }        else{            node.next = stack[i+1];        }    }     //返回数组的首个元素      return stack.first;  }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/206题目.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一些思考&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>136. Single Number</title>
    <link href="http://LikeeCat.github.io/2020/12/13/136.%20Single%20Number/"/>
    <id>http://LikeeCat.github.io/2020/12/13/136. Single Number/</id>
    <published>2020-12-13T09:05:13.000Z</published>
    <updated>2020-12-13T09:08:12.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/136题目.png" alt="题目"></p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从给出的内容来看,要找到数组中只出现一次的数</li><li>用字典去记录每一个数字出现的频率,大于1就从字典中删除,最后字典剩下的就是我们需要的target</li><li>题目中还有Follow up,让我们尝试不用多余的内存去做</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p><img src="/assets/img/136思路2.png" alt="思路1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution {    var dic :[Int:Int] = [:]    func singleNumber(_ nums: [Int]) -&gt; Int {        for i in nums{            if dic.keys.contains(i) {                dic.removeValue(forKey: i)            }            else{                dic[i] = 1;            }            }        return Int(dic.keys.first!);    }}</code></pre><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p><img src="/assets/img/136思路1.png" alt="思路2"></p><h1 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h1><pre><code>class Solution {func singleNumber(_ nums: [Int]) -&gt; Int {    var  a = 0    for i in nums{        a = a ^ i    }    return a;    }}</code></pre><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>这里用到了异或的计算,计算法则如下,具体的细则可以<a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin" target="_blank" rel="noopener">点击这里</a><br><img src="/assets/img/136异或运算.png" alt="运算法则"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/136题目.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一些思考&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>101. Symmetric Tree</title>
    <link href="http://LikeeCat.github.io/2020/12/13/101.%20Symmetric%20Tree/"/>
    <id>http://LikeeCat.github.io/2020/12/13/101. Symmetric Tree/</id>
    <published>2020-12-13T08:05:13.000Z</published>
    <updated>2020-12-13T08:38:52.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/101题目.png" alt="题目"></p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从给出的内容来看,看这个二叉树是不是一个镜像的二叉树,即它的左子树与右子树之间是<code>对称</code>的</li><li>那么他的左子树和右子树是镜像的,对于一个三层的二叉树来说就是,左子树的左侧节点和右子树的右侧节点是一致的,左子树的右侧节点和右子树的左侧节点是一致的</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="/assets/img/101思路.png" alt="思路"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     public var val: Int *     public var left: TreeNode? *     public var right: TreeNode? *     public init() { self.val = 0; self.left = nil; self.right = nil; } *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; } *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) { *         self.val = val *         self.left = left *         self.right = right *     } * } */ class Solution {  func isMirror(_ left:TreeNode?,_ right:TreeNode?) -&gt; Bool {    if left == nil &amp;&amp; right == nil {        return  true    }    if left == nil || right == nil {        return false    }    return (left?.val == right?.val) &amp;&amp; isMirror(left?.right, right?.left) &amp;&amp; isMirror(left?.left, right?.right)    }    func isSymmetric(_ root: TreeNode?) -&gt; Bool {            return isMirror(root,root)    }}</code></pre><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>这道题的重点还是要理解两个子树之间的关系,即怎样的两个子树即可互为镜像</p><pre><code>1. Their two roots have the same value2. The right subtree of each tree is a mirror reflection of the other tree</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/101题目.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一些思考&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>20. Valid Parentheses</title>
    <link href="http://LikeeCat.github.io/2020/12/13/Valid%20Parentheses/"/>
    <id>http://LikeeCat.github.io/2020/12/13/Valid Parentheses/</id>
    <published>2020-12-13T07:05:13.000Z</published>
    <updated>2020-12-13T07:57:06.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/assets/img/20题目.png" alt="图"></p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><ol><li>从题目给出的意思来看的话,这道题就是用Close brackets 来匹配 Open brackets,那么这个数组的数目必须是偶数个,否则肯定无法匹配</li><li>如果刚开始就是Close bracket那么也无法匹配</li><li>Open brackets 需要优先去匹配离他最近的 Close bracket,且中间不能有其他未匹配完的符号</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="/assets/img/20思路.png" alt="思路"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>class Solution {//存放未匹配到Close brackets 的数组var element:[Character] = []//匹配字符串用到的字典let validDic:[String:Character] = [&quot;[&quot;:&quot;]&quot;,&quot;{&quot;:&quot;}&quot;,&quot;(&quot;:&quot;)&quot;]func isValid(_ s: String) -&gt; Bool {    for i in s{            //如果是Open bracket,就放入brackets的数组        if i == &quot;[&quot; || i == &quot;{&quot; || i == &quot;(&quot;{            self.element.append(i)        }        else{                //如果Stack为空,那么就不匹配            if self.element.isEmpty {                return false            }            else{                    //找到栈顶的元素,与当前的i进行对比                let lastElement = String(self.element.last!)                if validDic[String.init(lastElement)] == i  {                    self.element.removeLast()                }                else{                    return false                }            }        }    }    //如果栈中不存在任何的元素,则证明匹配成功    return self.element.isEmpty}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/20题目.png&quot; alt=&quot;图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;一些思考&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://LikeeCat.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>NSDictionary 使用中的一些问题</title>
    <link href="http://LikeeCat.github.io/2020/07/29/NSDictionary%20%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://LikeeCat.github.io/2020/07/29/NSDictionary 使用中的一些问题/</id>
    <published>2020-07-29T10:05:13.000Z</published>
    <updated>2020-07-28T17:40:21.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NSDictionary-使用中的一些问题"><a href="#NSDictionary-使用中的一些问题" class="headerlink" title="NSDictionary 使用中的一些问题"></a>NSDictionary 使用中的一些问题</h1><h2 id="1-dictionaryWithObjectsAndKeys"><a href="#1-dictionaryWithObjectsAndKeys" class="headerlink" title="1. dictionaryWithObjectsAndKeys"></a>1. dictionaryWithObjectsAndKeys</h2><pre><code>NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;12&quot;,@&quot;key&quot;,&quot;11&quot;,@&quot;age&quot;,nil];NSLog(@&quot;dic is %@&quot;,dic);</code></pre><p>我们在使用<code>dictionaryWithObjectsAndKeys</code>或者一些其他字面量去创建OC对象的时候，参数应该是<strong><em>Objective-C字符串</em></strong>，不是<strong><em>C语言</em></strong>的字符串</p><p>##2. 关于NSDictionary 转 JSON字符串的坑<br>我们经常能在网上搜到下面的内容</p><pre><code>-(NSString*)convertAlfredaJsonString:(NSDictionary *)dic{    NSString *jsonString = nil;    NSError *error;    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic                                                   options:NSJSONWritingPrettyPrinted                                                     error:&amp;error];    if (!jsonData) {        return @&quot;&quot;;    }     else {        jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];    }    return jsonString;}</code></pre><p>##坑<br>在你使用上面代码的时候，你生成的 json字符串中会带有<code>&quot;\n&quot;</code>的换行符，因为这个换行符，因为web、后端可能对换行符进行了一些处理，直接这么传过去，可能会出现问题</p><h2 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h2><pre><code>NSMutableString *occultStr = [NSMutableString stringWithString:jsonString];NSRange range = {0,jsonString.length};//去掉字符串中的空格[occultStr replaceOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot; options:NSLiteralSearch range:range];NSRange range2 = {0,occultStr.length};[occultStr replaceOccurrencesOfString:@&quot;\n&quot; withString:@&quot;&quot; options:NSLiteralSearch range:range2];</code></pre><p>在生成 json字符串后，将其中的<code>&quot;\n&quot;</code>、<code>&quot; &quot;</code>空格去掉，然后再传给后端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NSDictionary-使用中的一些问题&quot;&gt;&lt;a href=&quot;#NSDictionary-使用中的一些问题&quot; class=&quot;headerlink&quot; title=&quot;NSDictionary 使用中的一些问题&quot;&gt;&lt;/a&gt;NSDictionary 使用中的一些问题&lt;/
      
    
    </summary>
    
      <category term="tip" scheme="http://LikeeCat.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://LikeeCat.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>iOS中framework的相关命令</title>
    <link href="http://LikeeCat.github.io/2020/07/25/iOS%E4%B8%ADframework%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>http://LikeeCat.github.io/2020/07/25/iOS中framework的相关命令/</id>
    <published>2020-07-25T10:05:13.000Z</published>
    <updated>2020-07-25T05:34:15.339Z</updated>
    
    <content type="html"><![CDATA[<p>#查看framework支持的处理器架构</p><ol><li><p>进入framework的目录下面 </p><pre><code>cd /xxx/xxx.framework</code></pre></li><li><p>输入命令</p><pre><code>lipo -info xxxframework //这里的xxxframwork 是指framework中的二进制</code></pre></li></ol><a id="more"></a><h1 id="查看framework是静态库还是动态库"><a href="#查看framework是静态库还是动态库" class="headerlink" title="查看framework是静态库还是动态库"></a>查看framework是静态库还是动态库</h1><ol><li><p>输入命令</p><pre><code>file xxx/xxxframework //这里的xxxframework 是指framework中的二进制</code></pre></li></ol><p>#查看framework 中是否包含UIWebView</p><ol><li><p>进入项目目录下面 </p><pre><code>cd /xxx/xxx.framework</code></pre></li><li><p>输入命令</p><pre><code>find . -type f | grep -e &quot;.a&quot; -e &quot;.framework&quot; | xargs grep -s UIWebView</code></pre></li></ol><p>#xxx.framework contains unsupported architectures ‘[x86_64, i386]’</p><p>这个framework中包含x86_64, i386架构,这个在iOS中是不允许的</p><ol><li>在app对应的target -&gt; build phases -&gt; new Run Script Phase</li><li><p>输入命令</p><pre><code># Without further ado, here’s the script. Add a Run Script step to your build steps, put it after your step to embed frameworks, set it to use /bin/sh and enter the following script:APP_PATH=&quot;${TARGET_BUILD_DIR}/${WRAPPER_NAME}&quot;# This script loops through the frameworks embedded in the     application and# removes unused architectures.find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;EXTRACTED_ARCHS=()for ARCH in $ARCHSdo    echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)doneecho &quot;Merging extracted architectures: ${ARCHS}&quot;lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;${EXTRACTED_ARCHS[@]}&quot;rm &quot;${EXTRACTED_ARCHS[@]}&quot;echo &quot;Replacing original executable with thinned version&quot;rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;done</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#查看framework支持的处理器架构&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入framework的目录下面 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /xxx/xxx.framework
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输入命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lipo -info xxxframework //这里的xxxframwork 是指framework中的二进制
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="frame" scheme="http://LikeeCat.github.io/categories/frame/"/>
    
    
      <category term="framework" scheme="http://LikeeCat.github.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>github下载代码太慢</title>
    <link href="http://LikeeCat.github.io/2020/06/23/github%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2/"/>
    <id>http://LikeeCat.github.io/2020/06/23/github下载太慢/</id>
    <published>2020-06-23T10:05:13.000Z</published>
    <updated>2020-07-25T05:59:32.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>我们总是需要在github去下载一些代码,但是因为一些原因,下载的速度忽快忽慢,而一些第三方的网站号称可以代下载,但是也是会很慢,或者直接就下载不下来,这个时候我们就需要用到<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>来帮助我们下载.接下来我们以CocoaPods为例</p><pre><code>&lt;!-- more --&gt;</code></pre><h2 id="1-获取github的仓库地址"><a href="#1-获取github的仓库地址" class="headerlink" title="1.获取github的仓库地址"></a>1.获取github的仓库地址</h2><p><img src="/assets/img/clone Url.png" alt="仓库地址"></p><h2 id="2-登录码云并选择创建仓库"><a href="#2-登录码云并选择创建仓库" class="headerlink" title="2.登录码云并选择创建仓库"></a>2.登录码云并选择创建仓库</h2><p><img src="/assets/img/创建仓库.png" alt="创建仓库"></p><h2 id="3-导入仓库"><a href="#3-导入仓库" class="headerlink" title="3.导入仓库"></a>3.导入仓库</h2><p><img src="/assets/img/导入仓库.png" alt="创建仓库"><br>输入对应的仓库地址,完成后选择导入</p><h2 id="4-完成导入"><a href="#4-完成导入" class="headerlink" title="4.完成导入"></a>4.完成导入</h2><p>导入完成后你就可以在你的码云仓库中找到对应的仓库,这个时候再下载就会很快了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;p&gt;我们总是需要在github去下载一些代码,但是因为一些原因,下载的速度忽快忽慢,而一些第三方的网站号称可以代下载,但是也是会很慢,或者直接就
      
    
    </summary>
    
      <category term="github" scheme="http://LikeeCat.github.io/categories/github/"/>
    
    
      <category term="github" scheme="http://LikeeCat.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 加载txt文件</title>
    <link href="http://LikeeCat.github.io/2019/11/17/%20Flutter%20%E5%8A%A0%E8%BD%BDtxt%E6%96%87%E4%BB%B6/"/>
    <id>http://LikeeCat.github.io/2019/11/17/ Flutter 加载txt文件/</id>
    <published>2019-11-17T10:05:13.000Z</published>
    <updated>2019-11-17T03:22:51.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter-之加载txt文件"><a href="#Flutter-之加载txt文件" class="headerlink" title="Flutter 之加载txt文件"></a>Flutter 之加载txt文件</h2><p>我想要加载工程中的txt文件,网上搜了一圈,没有找到相关的内容,在此做一下脱坑的记录</p><h3 id="1-在工程下新建txt文件"><a href="#1-在工程下新建txt文件" class="headerlink" title="1.在工程下新建txt文件"></a>1.在工程下新建txt文件</h3><p> <img src="/assets/img/flutterpath.png" alt="路径"><br><a id="more"></a></p><h3 id="2-在pubspec-yaml中引用"><a href="#2-在pubspec-yaml中引用" class="headerlink" title="2.在pubspec.yaml中引用"></a>2.在pubspec.yaml中引用</h3><p>  assets:<br>        -data/agreeText.txt</p><h3 id="3-在dart文件中使用"><a href="#3-在dart文件中使用" class="headerlink" title="3.在dart文件中使用"></a>3.在dart文件中使用</h3><h4 id="引入头文件-并复制这个方法"><a href="#引入头文件-并复制这个方法" class="headerlink" title="引入头文件,并复制这个方法"></a>引入头文件,并复制这个方法</h4><p>import ‘package:flutter/services.dart’ show rootBundle;</p><p>Future<string> loadAsset() async {<br>  var a = await rootBundle.loadString(‘data/agreeText.txt’);<br>  return a;<br>}</string></p><h4 id="在widget中使用"><a href="#在widget中使用" class="headerlink" title="在widget中使用"></a>在widget中使用</h4><p>因为是异步函数,所以需要结合setseate来使用</p><pre><code> var _result = &quot;&quot;; dynamic result; void loadAssests() async { result = await loadAsset(); print(result); setState(() {   _result = result.toString();     });   }@overridevoid initState() { loadAssests();}@overrideWidget build(BuildContext context) {return new MaterialApp(  title: &apos;Welcome to Flutter&apos;,  home: new Scaffold(    appBar: new AppBar(      title: new Text(&apos;Welcome to Flutter&apos;),    ),    body: new Center(      child: new Text(_result),    ),  ),);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flutter-之加载txt文件&quot;&gt;&lt;a href=&quot;#Flutter-之加载txt文件&quot; class=&quot;headerlink&quot; title=&quot;Flutter 之加载txt文件&quot;&gt;&lt;/a&gt;Flutter 之加载txt文件&lt;/h2&gt;&lt;p&gt;我想要加载工程中的txt文件,网上搜了一圈,没有找到相关的内容,在此做一下脱坑的记录&lt;/p&gt;
&lt;h3 id=&quot;1-在工程下新建txt文件&quot;&gt;&lt;a href=&quot;#1-在工程下新建txt文件&quot; class=&quot;headerlink&quot; title=&quot;1.在工程下新建txt文件&quot;&gt;&lt;/a&gt;1.在工程下新建txt文件&lt;/h3&gt;&lt;p&gt; &lt;img src=&quot;/assets/img/flutterpath.png&quot; alt=&quot;路径&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://LikeeCat.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://LikeeCat.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>面试问题汇总</title>
    <link href="http://LikeeCat.github.io/2019/06/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://LikeeCat.github.io/2019/06/12/面试问题汇总/</id>
    <published>2019-06-12T10:05:13.000Z</published>
    <updated>2019-07-20T05:16:25.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于离屏渲染的问题"><a href="#关于离屏渲染的问题" class="headerlink" title="关于离屏渲染的问题"></a>关于离屏渲染的问题</h2><ol><li><p>什么是mask</p><blockquote><p>一个图层可以有一个和它相关的mask(蒙版),mask是一个拥有alpha的位图,当像素和它下面的像素合成之前都会把mask应用到图层的像素上面,当你要设置一个图层的圆角半径的时候,你可以有效的在图层上设置一个mask,最终只有mask中显示出来的部分才会被渲染出来</p><a id="more"></a></blockquote></li><li><p>设置圆角的时候是什么触发了离屏渲染,为什么会触发离屏渲染</p><blockquote><p>是因为mask,layer的圆角将mask应用到一个图层上,core Animation为了应用这个mask,会强制进行屏幕外的渲染.这对GPU产生重负.</p></blockquote></li><li>离屏渲染为什么消耗性能<blockquote><p>离屏渲染合成计算是非常昂贵的,直接将图层合成到桢的缓冲区(在屏幕上),比先创建在屏幕外的缓冲区,然后渲染到纹理中,最后将结果渲染到桢的缓冲区中要廉价的多.因为其中涉及到了两次昂贵的环境切换(转换环境到屏幕外缓冲区,再转换环境到帧缓冲区).<br>为 layer 使用mask或者设置圆角半径(特殊的mask)会造成屏幕外渲染，产生阴影也会如此。</p></blockquote></li></ol><h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><ol><li><p>block使用weakSelf关键字的时候有什么坏处</p><blockquote><p>有可能在你使用block的时候,这个对象就已经被销毁了</p></blockquote></li><li><p>使用weakSelf后,如何避免对象已经被销毁</p><blockquote><p>使用strongSelf来保证在block的执行过程中这个变量不被释放</p></blockquote></li><li><p>什么是weakSelf</p><blockquote><p>weakSelf 是为了block不持有self，避免Retain Circle循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf</p></blockquote></li><li><p>什么是strongSelf</p><blockquote><p>strongSelf的目的是因为一旦进入block执行，假设不允许self在这个执行过程中释放，就需要加入strongSelf。block执行完后这个strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf</p></blockquote></li></ol><h2 id="static-const"><a href="#static-const" class="headerlink" title="static const"></a>static const</h2><ol><li><p>什么是extern</p><blockquote><p>extern是计算机语言中的一个关键字，可置于变量或者函数前，以表示变量或者函数的定义在别的文件中。提示编译器遇到此变量或函数时，在其它模块中寻找其定</p></blockquote></li><li><p>如何使用</p><pre><code>//xxx.hextern NSString *const EocStringConstant;//xxx.mNSString *const EocStringConstant = @&quot;VALUE&quot;</code></pre></li><li>为什么使用常量的时候要使用const,而不是宏<blockquote><p>1.编译时刻:宏是预编译（编译之前处理），const是编译阶段。<br> 2.编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。<br> 3.宏的好处:宏能定义一些函数，方法。 const不能。<br> 4.宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。    </p></blockquote></li></ol><h2 id="lldb命令"><a href="#lldb命令" class="headerlink" title="lldb命令"></a>lldb命令</h2><ol><li>p 和 po 的区别</li></ol><blockquote><pre><code>p  -- Evaluate an expression on the current thread.  Displays any           returned value with LLDB&apos;s default formatting.          使用的是lldb中默认的formatting</code></pre></blockquote><blockquote><p>po        – Evaluate an expression on the current thread.  Displays any<br>               returned value with formatting controlled by the type’s author.<br>               使用的formatter  是lldb中由类型的作者自己控制的(重写对象的description方法)</p></blockquote><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ol><li><p>nsarray 的 mutablecopy 是深拷贝还是浅拷贝<br>是深拷贝,它在堆上开辟了一块新的内存空间</p></li><li><p>深拷贝是什么<br>不只是拷贝指针,并且拷贝了值</p></li><li><p>浅拷贝是什么<br>是拷贝指针,一旦改变,连同拷贝前的也会发生改变</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于离屏渲染的问题&quot;&gt;&lt;a href=&quot;#关于离屏渲染的问题&quot; class=&quot;headerlink&quot; title=&quot;关于离屏渲染的问题&quot;&gt;&lt;/a&gt;关于离屏渲染的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是mask&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个图层可以有一个和它相关的mask(蒙版),mask是一个拥有alpha的位图,当像素和它下面的像素合成之前都会把mask应用到图层的像素上面,当你要设置一个图层的圆角半径的时候,你可以有效的在图层上设置一个mask,最终只有mask中显示出来的部分才会被渲染出来&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://LikeeCat.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://LikeeCat.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>NSArray之深浅拷贝</title>
    <link href="http://LikeeCat.github.io/2019/06/11/NSArray%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://LikeeCat.github.io/2019/06/11/NSArray之深浅拷贝/</id>
    <published>2019-06-11T10:05:13.000Z</published>
    <updated>2019-07-20T05:15:54.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自定义对象"><a href="#1-自定义对象" class="headerlink" title="1. 自定义对象"></a>1. 自定义对象</h2><ol><li><p>假设我有一个Student类</p><pre><code>@interface Student()&lt;NSCopying,NSMutableCopying&gt;@property (nonatomic,copy)NSString *name;@property (nonatomic,assign)NSInteger age;@end</code></pre> <a id="more"></a></li><li><p>生成两个Student对象</p><pre><code> Student *stu = [[Student alloc]initWithName:@&quot;a&quot; age:1];Student *stu1 = [[Student alloc]initWithName:@&quot;b&quot; age:2];</code></pre></li><li><p>用NSArray去把这两个对象加进数组,分别对数组进行copy 和 mutableCopy</p><pre><code>NSArray *arr = [NSArray arrayWithObjects:stu,stu1, nil];NSArray *arrCopy =  [arr copy] ;NSMutableArray *arrMuCopy = [arr mutableCopy];</code></pre></li><li><p>在arrMuCopy之后打断点查看结果</p><pre><code> po arr&lt;__NSArrayI 0x102900290&gt;(&lt;Student: 0x100646bc0&gt;,&lt;Student: 0x100647300&gt;) po arrCopy&lt;__NSArrayI 0x102900290&gt;(&lt;Student: 0x100646bc0&gt;,&lt;Student: 0x100647300&gt;)po arrMuCopy&lt;__NSArrayM 0x1029056f0&gt;(&lt;Student: 0x100646bc0&gt;,&lt;Student: 0x100647300&gt;)</code></pre><blockquote><p>从结果上来说,copy只是复制了一个指针,arr 和 arrCopy 在堆上的对象是同一个.而arrMuCopy则是创建了新的内存地址,即创建了一个新的NSMutableArray的对象,但是array中包含的自定义对象没有复制.</p></blockquote></li><li><p>重写Student的description方法</p><pre><code>-(NSString *)description{ return [NSString stringWithFormat:@&quot;name:%@\n age :%d&quot;,self.name,self.age]; }</code></pre></li><li><p>在copy 和 mutableCopy 结束后打断点</p><pre><code>  NSArray *arr = [NSArray arrayWithObjects:stu,stu1, nil];NSArray *arrCopy =  [arr copy] ;NSMutableArray *arrMuCopy = [arr mutableCopy];[stu changeName:@&quot;ccc&quot;]; po arr&lt;__NSArrayI 0x1029002c0&gt;(name:ccc age :1,name:b age :2) po arrCopy&lt;__NSArrayI 0x1029002c0&gt;(name:ccc age :1,name:b age :2)po arrMuCopy&lt;__NSArrayM 0x102909590&gt;(name:ccc age :1,name:b age :2)</code></pre></li></ol><p>结果也论证了这一点,mutableCopy后并没有将array中的对象进行复制</p><h2 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h2><ol><li><p>用NSArray去把这两个对象加进数组,分别对数组进行copy 和 mutableCopy</p><pre><code>NSArray *arr = [NSArray arrayWithObjects:@&quot;aaa&quot;,@&quot;bbb&quot;, nil];NSArray *arrCopy =  [arr copy] ;NSMutableArray *arrMuCopy = [arr mutableCopy];</code></pre></li><li><p>在copy 和 mutableCopy 结束后打断点</p><pre><code>po arr&lt;__NSArrayI 0x100504700&gt;(aaa,bbb)po arrCopy&lt;__NSArrayI 0x100504700&gt;(aaa,bbb)po arrMuCopy&lt;__NSArrayM 0x100503290&gt;(aaa,bbb) p arr[0](__NSCFConstantString *) $4 = 0x00000001000020d0 @&quot;aaa&quot;p arrCopy[0](__NSCFConstantString *) $7 = 0x00000001000020d0 @&quot;aaa&quot;p arrMuCopy[0](__NSCFConstantString *) $6 = 0x00000001000020d0 @&quot;aaa&quot;</code></pre></li></ol><p>结果也论证了这一点,mutableCopy后并没有将array中的对象进行复制</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-自定义对象&quot;&gt;&lt;a href=&quot;#1-自定义对象&quot; class=&quot;headerlink&quot; title=&quot;1. 自定义对象&quot;&gt;&lt;/a&gt;1. 自定义对象&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设我有一个Student类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface Student()&amp;lt;NSCopying,NSMutableCopying&amp;gt;
@property (nonatomic,copy)NSString *name;
@property (nonatomic,assign)NSInteger age;
@end
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/categories/NSArray/"/>
    
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/tags/NSArray/"/>
    
  </entry>
  
  <entry>
    <title>Xcode快捷键</title>
    <link href="http://LikeeCat.github.io/2019/05/30/Xcode%20%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"/>
    <id>http://LikeeCat.github.io/2019/05/30/Xcode 快捷操作/</id>
    <published>2019-05-30T01:05:58.000Z</published>
    <updated>2019-07-20T05:15:34.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编辑的快捷键"><a href="#编辑的快捷键" class="headerlink" title="编辑的快捷键"></a>编辑的快捷键</h2><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>command + ↑</td><td>到达文件头部</td></tr><tr><td>command +  ↓</td><td>到达文件尾部</td></tr><tr><td>command + [</td><td>向左移动代码</td></tr><tr><td>command + ]</td><td>向右移动代码</td></tr><tr><td>option + command + [</td><td>向上移动代码</td></tr><tr><td>option + command + ]</td><td>向下移动代码</td></tr><tr><td>command + /</td><td>快速注释或者取消注释</td></tr><tr><td>Ctrl + A</td><td>移动光标到本行行首 </td></tr><tr><td>Ctrl + E</td><td>移动光标到本行行尾 </td></tr><tr><td>option + →</td><td>移动光标到下一个单词</td></tr><tr><td>option +  ←</td><td>移动光标到上一个单词</td></tr></tbody></table><a id="more"></a><h2 id="视图快捷键"><a href="#视图快捷键" class="headerlink" title="视图快捷键"></a>视图快捷键</h2><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>shift + command  + y</td><td>隐藏/打开控制台</td></tr><tr><td>Ctrl + command + ↑↓</td><td>快速切换.h和.m文件</td></tr><tr><td>Ctrl + command + → ←</td><td>打开下一个/上一个文件</td></tr></tbody></table><h2 id="搜索快捷键"><a href="#搜索快捷键" class="headerlink" title="搜索快捷键"></a>搜索快捷键</h2><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>command  + f</td><td>在当前文件搜索</td></tr><tr><td>shift + command + f</td><td>打开全局搜索</td></tr><tr><td>command  + g</td><td>跳到下一个搜索结果</td></tr><tr><td>shift +command  + g</td><td>跳到上一个搜索结果</td></tr><tr><td>shift +command  + o</td><td>快速打开一个文件</td></tr></tbody></table><h1 id="编译快捷键"><a href="#编译快捷键" class="headerlink" title="编译快捷键"></a>编译快捷键</h1><table><thead><tr><th>快捷键名称</th><th>作用</th></tr></thead><tbody><tr><td>command  + r</td><td>运行</td></tr><tr><td>command  + b</td><td>编译</td></tr><tr><td>shift + command  + k</td><td>清除工程</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编辑的快捷键&quot;&gt;&lt;a href=&quot;#编辑的快捷键&quot; class=&quot;headerlink&quot; title=&quot;编辑的快捷键&quot;&gt;&lt;/a&gt;编辑的快捷键&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;command + ↑&lt;/td&gt;
&lt;td&gt;到达文件头部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command +  ↓&lt;/td&gt;
&lt;td&gt;到达文件尾部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command + [&lt;/td&gt;
&lt;td&gt;向左移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command + ]&lt;/td&gt;
&lt;td&gt;向右移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option + command + [&lt;/td&gt;
&lt;td&gt;向上移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option + command + ]&lt;/td&gt;
&lt;td&gt;向下移动代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;command + /&lt;/td&gt;
&lt;td&gt;快速注释或者取消注释&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + A&lt;/td&gt;
&lt;td&gt;移动光标到本行行首 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + E&lt;/td&gt;
&lt;td&gt;移动光标到本行行尾 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option + →&lt;/td&gt;
&lt;td&gt;移动光标到下一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;option +  ←&lt;/td&gt;
&lt;td&gt;移动光标到上一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="tip" scheme="http://LikeeCat.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://LikeeCat.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中文排序</title>
    <link href="http://LikeeCat.github.io/2019/05/29/iOS%E4%B8%AD%E6%96%87%E6%8E%92%E5%BA%8F/"/>
    <id>http://LikeeCat.github.io/2019/05/29/iOS中文排序/</id>
    <published>2019-05-29T11:05:58.000Z</published>
    <updated>2019-07-20T05:15:24.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h1><h2 id="localizedCompare"><a href="#localizedCompare" class="headerlink" title="localizedCompare(_:)"></a>localizedCompare(_:)</h2><p>Compares the string and a given string using a localized comparison.</p><blockquote><p>在NSString 的 API 中有这个方法,假设你的手机使用的是中文,就可以根据中文排序</p></blockquote><a id="more"></a><h2 id="NSSortDescriptor"><a href="#NSSortDescriptor" class="headerlink" title="NSSortDescriptor"></a>NSSortDescriptor</h2><p>An immutable description of how to order a collection of objects based on a property common to all the objects.</p><blockquote><p>可以根据集合中的对象的某一个属性对这个集合进行排序</p></blockquote><h2 id="initWithKey-ascending-selector"><a href="#initWithKey-ascending-selector" class="headerlink" title="initWithKey:ascending:selector:"></a>initWithKey:ascending:selector:</h2><pre><code>- (instancetype)initWithKey:(NSString *)key               ascending:(BOOL)ascending                selector:(SEL)selector;根据给出的key 升序还是降序 还有使用selector来初始化</code></pre><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><pre><code>@interface person : NSObject@property (nonatomic,strong)NSString *name;@property (nonatomic,strong)NSString *phone;@end</code></pre><h2 id="定义对象的集合"><a href="#定义对象的集合" class="headerlink" title="定义对象的集合"></a>定义对象的集合</h2><pre><code>person *p = [[person alloc]initWithName:@&quot;小小&quot; phone:@&quot;13322223333&quot;];person *p1 = [[person alloc]initWithName:@&quot;小二&quot; phone:@&quot;13322223333&quot;];person *p2 = [[person alloc]initWithName:@&quot;校小&quot; phone:@&quot;13322223333&quot;];NSMutableArray *arr  = [NSMutableArray arrayWithArray:@[p,p1,p2]];</code></pre><h2 id="定义排序方法"><a href="#定义排序方法" class="headerlink" title="定义排序方法"></a>定义排序方法</h2><pre><code>NSArray *sortDescriptors = [NSArray arrayWithObject:[NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES selector:@selector(localizedCompare:)]];</code></pre><h2 id="进行排序"><a href="#进行排序" class="headerlink" title="进行排序"></a>进行排序</h2><pre><code>[arr sortUsingDescriptors:sortDescriptors];</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序方法&quot;&gt;&lt;a href=&quot;#排序方法&quot; class=&quot;headerlink&quot; title=&quot;排序方法&quot;&gt;&lt;/a&gt;排序方法&lt;/h1&gt;&lt;h2 id=&quot;localizedCompare&quot;&gt;&lt;a href=&quot;#localizedCompare&quot; class=&quot;headerlink&quot; title=&quot;localizedCompare(_:)&quot;&gt;&lt;/a&gt;localizedCompare(_:)&lt;/h2&gt;&lt;p&gt;Compares the string and a given string using a localized comparison.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在NSString 的 API 中有这个方法,假设你的手机使用的是中文,就可以根据中文排序&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tip" scheme="http://LikeeCat.github.io/categories/tip/"/>
    
    
      <category term="tip" scheme="http://LikeeCat.github.io/tags/tip/"/>
    
  </entry>
  
  <entry>
    <title>OC中函数的一些小技巧</title>
    <link href="http://LikeeCat.github.io/2019/04/16/OC%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://LikeeCat.github.io/2019/04/16/OC中函数的一些理解/</id>
    <published>2019-04-16T03:18:13.000Z</published>
    <updated>2019-06-12T06:57:48.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近在做一个复杂的界面，涉及到 UINavigationController 、UITabBarController、UIViewController、之间的函数调用，需要把原先在UIViewController中的功能转移到UITabBarController 或者 UINavigationController中，这就导致了界面产生冲突，我已经在UIViewController中完成了这个方法，怎么在UINavigationController中调用</p><a id="more"></a><h2 id="关于objc-msgSend"><a href="#关于objc-msgSend" class="headerlink" title="关于objc_msgSend"></a>关于objc_msgSend</h2><p>在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说叫做传递消息。消息有名称 (name) 或选择子 (selector) ,可以接受参数，并且还有可能有返回值。   </p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>类的方法列表会把selector的名称的映射到相对应的方法上，使得“动态消息派发系统”能够据此找到相应的方法。这些方法均以函数指针的形式来表示，这种指针就是IMP</p><pre><code>id (*IMP) = (id,SEL,...) </code></pre><h3 id="selector-SEL-的生成"><a href="#selector-SEL-的生成" class="headerlink" title="selector(SEL)的生成"></a>selector(SEL)的生成</h3><p>SEL的生成分为三种情况<br>1.无参</p><pre><code>SEL selector = NSSelectorFromString(@&quot;log&quot;);</code></pre><p>2.有参数</p><pre><code>SEL selector = NSSelectorFromString(@&quot;logWithAll:type:&quot;);</code></pre><h3 id="IMP的生成"><a href="#IMP的生成" class="headerlink" title="IMP的生成"></a>IMP的生成</h3><pre><code>IMP imp1 = [self methodForSelector:selector];</code></pre><h3 id="方法的执行"><a href="#方法的执行" class="headerlink" title="方法的执行"></a>方法的执行</h3><pre><code>- (NSString *)logWithAll:(NSString *)name type:(NSString *)type{    NSLog(@&quot;name is %@  type is %@&quot;,name,type);    return @&quot;aaa&quot;;}if ([self respondsToSelector:selector]) {    NSString* (*func)(id,SEL,NSString*,NSString*) = (void *)imp1;    NSString *result =  func(self,selector,@&quot;哈哈&quot;,@&quot;hehe&quot;);    NSLog(@&quot;result is %@&quot;,result);}</code></pre><p>##结果<br>结构大概就是这样的</p><pre><code>NSString* (*func)(id,SEL,NSString*,NSString*) = (void *)imp1;返回值                     parmar1  parmar2       IMP</code></pre><p>调用</p><pre><code>NSString *result =  func(self,selector,@&quot;哈哈&quot;,@&quot;hehe&quot;);</code></pre><p>输出结果</p><p><img src="/assets/img/oc函数.png" alt="结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近在做一个复杂的界面，涉及到 UINavigationController 、UITabBarController、UIViewController、之间的函数调用，需要把原先在UIViewController中的功能转移到UITabBarController 或者 UINavigationController中，这就导致了界面产生冲突，我已经在UIViewController中完成了这个方法，怎么在UINavigationController中调用&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://LikeeCat.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://LikeeCat.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>把博客从简书搬出来</title>
    <link href="http://LikeeCat.github.io/2019/03/16/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E4%BB%8E%E7%AE%80%E4%B9%A6%E6%90%AC%E5%87%BA%E6%9D%A5/"/>
    <id>http://LikeeCat.github.io/2019/03/16/把博客从简书搬出来/</id>
    <published>2019-03-16T11:05:58.000Z</published>
    <updated>2019-05-30T02:43:05.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起"><a href="#起" class="headerlink" title="起"></a>起</h1><p>忽然觉得大多数的写作的地方都太浮躁了，自己想找个安静的角落，写一写关于技术、生活、旅游方面的姑且认为是文章啦，于是就有了想自己做一个静态网站的想法。</p><h1 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h1><p>花了一周的时间想了很久，最终还是在 GitHub 上安家了，离开自己的舒服区，跑来折腾前端的我也是有够拼的。接下来就慢慢的写，让自己能够得到一些沉淀吧。折腾了一天的我，突然发现天也已经暗了下来，不过总算是完成了一大半的工程。<br><a id="more"></a></p><h1 id="终"><a href="#终" class="headerlink" title="终"></a>终</h1><p>这应该就是我的桃花源吧。<br>晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林<br><img src="/assets/img/搬家.png" alt="桃花源"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起&quot;&gt;&lt;a href=&quot;#起&quot; class=&quot;headerlink&quot; title=&quot;起&quot;&gt;&lt;/a&gt;起&lt;/h1&gt;&lt;p&gt;忽然觉得大多数的写作的地方都太浮躁了，自己想找个安静的角落，写一写关于技术、生活、旅游方面的姑且认为是文章啦，于是就有了想自己做一个静态网站的想法。&lt;/p&gt;
&lt;h1 id=&quot;接下来&quot;&gt;&lt;a href=&quot;#接下来&quot; class=&quot;headerlink&quot; title=&quot;接下来&quot;&gt;&lt;/a&gt;接下来&lt;/h1&gt;&lt;p&gt;花了一周的时间想了很久，最终还是在 GitHub 上安家了，离开自己的舒服区，跑来折腾前端的我也是有够拼的。接下来就慢慢的写，让自己能够得到一些沉淀吧。折腾了一天的我，突然发现天也已经暗了下来，不过总算是完成了一大半的工程。&lt;br&gt;
    
    </summary>
    
      <category term="日记" scheme="http://LikeeCat.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://LikeeCat.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中 CSV格式文件读写</title>
    <link href="http://LikeeCat.github.io/2019/03/16/iOS-%E4%B8%AD-CSV%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://LikeeCat.github.io/2019/03/16/iOS-中-CSV格式文件读写/</id>
    <published>2019-03-16T09:09:15.000Z</published>
    <updated>2019-06-12T06:56:19.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h1><p><strong>逗号分隔值</strong>（Comma-Separated Values，<strong>CSV</strong>，有时也称为<strong>字符分隔值</strong>，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本)。（:来自百度百科）</p><blockquote><p>CSV其实就是一个<strong>纯文本</strong>,那么对应到 Objective-C 中，他就是一个<code>NSString</code>,对应到 Swift 中就是一个<code>String</code></p></blockquote><a id="more"></a><h1 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h1><blockquote><p>sj_mino1001.jpg,715282,4FB55FE8<br>sj_mino1002.jpg,471289,93203C5C<br>sj_mino1003.jpg,451929,C4E80467<br>这个就是一个简单的CSV文件,每个值之间用,分割,在一行数据结束的时候才换行。</p></blockquote><h1 id="CSV读取"><a href="#CSV读取" class="headerlink" title="CSV读取"></a>CSV读取</h1><p>假设我们的项目中有一个 csv 文件，叫做1</p><p>1.获取文件路径</p><pre><code>NSString  *path = [[NSBundle mainBundle]pathForResource:@&quot;1&quot; ofType:@&quot;csv&quot;];</code></pre><p>2.将此文件转码为一个字符串</p><pre><code>NSError *error = nil;//GBK编码NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:0x80000632 error:&amp;error];//UTF8编码NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error];</code></pre><p>3.切割字符串，可以拿到每一行的数据</p><pre><code>//取出每一行的数据NSArray *_allLinedStrings = [fileContents componentsSeparatedByString:@&quot;\r\n&quot;];</code></pre><p>4.如果有表头可以对表头进行处理，即对第一行数据进行处理</p><pre><code>__block NSInteger nameRow = 0;__block NSInteger phoneRow = 0;NSArray *firstLine = [_allLinedStrings[0] componentsSeparatedByString:@&quot;,&quot;];[firstLine enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {NSString *line = obj;if ([line isEqualToString:@&quot;客户名称&quot;]){    nameRow = idx;}else if ([line isEqualToString:@&quot;手机号&quot;]){    phoneRow = idx;}}];</code></pre><p>5.对数据进行处理</p><pre><code>[_allLinedStrings enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    if (idx == 0) {    }    else{      NSString *str = obj;        NSArray *array = [str componentsSeparatedByString:@&quot;,&quot;];       //获取到某一行的数据，切割这个字符串就可以拿到这一行的值，然后在进行下一步的处理    }     }];</code></pre><h1 id="CSV文件的写入"><a href="#CSV文件的写入" class="headerlink" title="CSV文件的写入"></a>CSV文件的写入</h1><p>假设我们有一个 likee.csv 需要放在Documents目录下</p><p>1.创建写入路径</p><pre><code>NSString *fileNameStr = @&quot;likee.Csv&quot;;NSString *DocPath = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:fileNameStr];</code></pre><p>2.够造需要写入的数据</p><pre><code>NSString *str = @&quot;11111,22222,33333,44444\n&quot;;NSMutableString *csvString = [NSMutableString string];for (int i = 0; i&lt; 400; i ++) { [csvString appendString:str]; };</code></pre><p>3.够造为NSData，并使用NSData进行文件的写入。</p><pre><code>NSData *data = [csvString dataUsingEncoding:NSUTF8StringEncoding];[data writeToFile:DocPath atomically:YES];</code></pre><h1 id="编码格式的坑"><a href="#编码格式的坑" class="headerlink" title="编码格式的坑"></a>编码格式的坑</h1><p>在 mac 下文本的默认编码格式使用的是UTF-8，在 windows 的 Excel 上，对中文的处理是GBK,所以可能会造成乱码的问题。如果读取文件是无法读出内容，就和使用的编码格式有关。所以建议先使用UTF-8进行解码，如果无法显示内容，再用GBK进行解码</p><pre><code> //UTF8编码NSString *fileContents = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error];if(!fileContents){    //GBK编码    fileContents = [NSString stringWithContentsOfFile:path encoding:0x80000632 error:&amp;error];}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSV&quot;&gt;&lt;a href=&quot;#CSV&quot; class=&quot;headerlink&quot; title=&quot;CSV&quot;&gt;&lt;/a&gt;CSV&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;逗号分隔值&lt;/strong&gt;（Comma-Separated Values，&lt;strong&gt;CSV&lt;/strong&gt;，有时也称为&lt;strong&gt;字符分隔值&lt;/strong&gt;，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本)。（:来自百度百科）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CSV其实就是一个&lt;strong&gt;纯文本&lt;/strong&gt;,那么对应到 Objective-C 中，他就是一个&lt;code&gt;NSString&lt;/code&gt;,对应到 Swift 中就是一个&lt;code&gt;String&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://LikeeCat.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://LikeeCat.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSArray 之 SEL 的保存</title>
    <link href="http://LikeeCat.github.io/2019/02/27/NSArray%20%E4%B9%8B%20SEL%20%E7%9A%84%E4%BF%9D%E5%AD%98/"/>
    <id>http://LikeeCat.github.io/2019/02/27/NSArray 之 SEL 的保存/</id>
    <published>2019-02-27T10:05:13.000Z</published>
    <updated>2019-06-12T06:56:17.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近在初始化类的时候，会有很多没有返回值的初始化方法需要调用，每次都需要再写一遍，所以想把函数装进 NSArray 中可以自动调用。结果查了一下真的可以，所以做个笔记记一下</p><a id="more"></a><pre><code>- (void)viewDidLoad {    [super viewDidLoad];    NSString* A = NSStringFromSelector(@selector(loadA));    NSString* B = NSStringFromSelector(@selector(loadB));    NSString* C = NSStringFromSelector(@selector(loadC));    NSArray *arr = @[A,B,C];    [arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {        NSString *selector = obj;        if (!self) { return; }        SEL performSelector = NSSelectorFromString(selector);        if ([self respondsToSelector:performSelector]){            [self performSelector:performSelector];        }    }];}- (void)loadA{    NSLog(@&quot;call load A +++++++&quot;);}- (void)loadB{    NSLog(@&quot;call load B ++++++++&quot;);}- (void)loadC{    NSLog(@&quot;call load C +++++&quot;);}</code></pre><p>然后就写了一个小 demo,写完后报了警告，查过<a href="https://www.jianshu.com/p/6517ab655be7" target="_blank" rel="noopener">爆栈热门 iOS 问题</a>后，解决了这个问题。<br><img src="https://upload-images.jianshu.io/upload_images/2239937-b6801e1b52041ae2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>NSString* A = NSStringFromSelector(@selector(loadA));NSString* B = NSStringFromSelector(@selector(loadB));NSString* C = NSStringFromSelector(@selector(loadC));NSArray *arr = @[A,B,C];[arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {    NSString *selector = obj;    if (!self) { return; }    SEL performSelector = NSSelectorFromString(selector);    IMP imp = [self methodForSelector:performSelector];    void (*func)(id, SEL) = (void *)imp;    func(self, performSelector);}];</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;最近在初始化类的时候，会有很多没有返回值的初始化方法需要调用，每次都需要再写一遍，所以想把函数装进 NSArray 中可以自动调用。结果查了一下真的可以，所以做个笔记记一下&lt;/p&gt;
    
    </summary>
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/categories/NSArray/"/>
    
    
      <category term="NSArray" scheme="http://LikeeCat.github.io/tags/NSArray/"/>
    
  </entry>
  
  <entry>
    <title>UITableView reloadData 滑不到底部</title>
    <link href="http://LikeeCat.github.io/2019/02/18/UITableView%20reloadData%20%E6%BB%91%E4%B8%8D%E5%88%B0%E5%BA%95%E9%83%A8/"/>
    <id>http://LikeeCat.github.io/2019/02/18/UITableView reloadData 滑不到底部/</id>
    <published>2019-02-18T10:05:13.000Z</published>
    <updated>2019-05-29T04:38:01.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近有个需求，在 tableView <code>reloadData</code>结束后，需要滑动到底部，可是总是不能准确的滚动到底部。自然而言的就想到了三个方法，查看了一下有关的文档</p><ol><li>layoutSubviews</li><li>setNeedsLayout</li><li>layoutIfNeeded</li></ol><a id="more"></a><h3 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h3><p>Lays out subviews.</p><h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p><p>You should not call this method directly. If you want to force a layout update, call the <code>setNeedsLayout</code> method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the <code>layoutIfNeeded</code> method.</p><p>在子类中，如果你需要更加准确的定位，你可以重写这个方法。如果 autoresizing 和 constraint不能为你提供你想要做的。你可以自己设置subviews的 frame。<br>你不应该直接调用这个方法，如果你想要强制更新布局，应该调用<code>setNeedsLayout</code>,在下一次绘图更新之前，如果你想要立刻的更新布局，需要调用 <code>layoutIfNeeded</code></p><h3 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h3><p>Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.</p><h4 id="Discussion-1"><a href="#Discussion-1" class="headerlink" title="Discussion"></a>Discussion</h4><p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.<br>你在想要更新 view 的 subviews 的布局的时候，可以在主线程调用此方法。此方法记录请求并且立即返回。因为这个方法不强制立即更新，而是等待下一个周期更新，你可以使用此方法来让很多 views 的布局失效，并且这样做可以把所有布局更新合并到一个更新周期，这通常会提高性能。</p><h3 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h3><p>Lays out the subviews immediately, if layout updates are pending.</p><h4 id="Discussion-2"><a href="#Discussion-2" class="headerlink" title="Discussion"></a>Discussion</h4><p>Use this method to force the view to update its layout immediately. When using Auto Layout, the layout engine updates the position of views as needed to satisfy changes in constraints. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root. If no layout updates are pending, this method exits without modifying the layout or calling any layout-related callbacks.<br>使用此方法强制视图立即更新其布局。使用“自动布局”时，布局引擎会根据需要更新视图的位置，以满足约束的更改，使用一个 view 作为 rootView ，此方法从根开始布局视图子树。如果没有约束需要更新，此方法会退出，不会修改 layout 或者调用和此 layout 有关的回调。</p><h2 id="stackoverflow上的提问"><a href="#stackoverflow上的提问" class="headerlink" title="stackoverflow上的提问"></a>stackoverflow上的提问</h2><p>在 stackoverflow上有查到一个问题， <a href="https://stackoverflow.com/questions/16071503/how-to-tell-when-uitableview-has-completed-reloaddata" target="_blank" rel="noopener">How to tell when UITableView has completed ReloadData?</a>，提问的人想要滚动 tableView 到底部，发现调用直接 reloadData，然后滚动没有滚动到最底部，提出了这个问题。 这个下面有很多很多的答案，具体的如下：<br>1.调用<code>layoutIfNeeded</code>强制的刷新布局，接着执行scrollToRowAtIndexPath,滚动到底部，确实是帮助我们解决了这个问题。</p><pre><code>[self.tableView reloadData];[self.tableView layoutIfNeeded];NSIndexPath* indexPath = [NSIndexPath indexPathForRow: ([self.tableView numberOfRowsInSection:([self.tableView     numberOfSections]-1)]-1) inSection: ([self.tableView numberOfSections]-1)];[self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES];</code></pre><p>原因：</p><blockquote><p>The reload happens during the next layout pass, which normally happens when you return control to the run loop (after, say, your button action or whatever returns).<br>So one way to run something after the table view reloads is simply to force the table view to perform layout immediately<br>重新加载发生在下一个布局过程中，这通常发生在将控制返回到运行循环时（例如，您的按钮操作或任何返回之后）。<br>所以，在tableView reloads 后可以立刻强制更新布局。</p></blockquote><ol start="2"><li><p>调用<code>dispatch_async(dispatch_get_main_queue(), ^{})</code></p><pre><code>[self.tableView reloadData]; dispatch_async(dispatch_get_main_queue(), ^{ NSIndexPath* indexPath = [NSIndexPath indexPathForRow: ([self.tableView numberOfRowsInSection:([self.tableView numberOfSections]-1)]-1) inSection:([self.tableView numberOfSections]-1)]; [self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; });</code></pre><p>原因</p></li></ol><blockquote><p>depending on how big your table data source is, you can animate going to the bottom of the tableview in the same run loop. If you try your test code with a huge table, your trick of using GCD to delay scrolling until the next run loop will work, whereas immediately scrolling will fail. But anyways, thanks for this trick!<br>但是这种方式并不总是能解决问题,使用GCD来延迟滑动到下一个 runloop，但是立即滑动的话，就会出错。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的 tableView 在 <code>reloadData</code>后，无法滑动到底部，那么就可以这样做,在<code>reloadData</code>后，调用 <code>layoutIfNeeded</code>，来强制进行布局，然后在进行 tableView的滑动就可以了。</p><pre><code>[self.tableView reloadData];[self.tableView layoutIfNeeded];//do somthing you want</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;最近有个需求，在 tableView &lt;code&gt;reloadData&lt;/code&gt;结束后，需要滑动到底部，可是总是不能准确的滚动到底部。自然而言的就想到了三个方法，查看了一下有关的文档&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;layoutSubviews&lt;/li&gt;
&lt;li&gt;setNeedsLayout&lt;/li&gt;
&lt;li&gt;layoutIfNeeded&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="UITableView" scheme="http://LikeeCat.github.io/categories/UITableView/"/>
    
    
      <category term="UITableView" scheme="http://LikeeCat.github.io/tags/UITableView/"/>
    
  </entry>
  
  <entry>
    <title>Xcode10 【libray not found for -lstdc++.6.0.9 】</title>
    <link href="http://LikeeCat.github.io/2019/01/08/Xcode10%20%E3%80%90libray%20not%20found%20for%20-lstdc++.6.0.9%20%E3%80%91/"/>
    <id>http://LikeeCat.github.io/2019/01/08/Xcode10 【libray not found for -lstdc++.6.0.9 】/</id>
    <published>2019-01-07T18:05:13.000Z</published>
    <updated>2019-05-29T04:38:37.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>上周在打包上传后，报了一个警告，大致的意思就是这样的：<code>2019年3月必须使用Xcode 10.1或更高版本</code>，此时的我还在用 Xcode 9，刚好最近刚上了包，就升级了Xcode 10<br><a id="more"></a></p><h2 id="开始采坑"><a href="#开始采坑" class="headerlink" title="开始采坑"></a>开始采坑</h2><p>1、升级完成后直接报了<code>libray not found for -lstdc++.6.0.9</code>，在 Xcode 10 Release Notes 中有着如下的描述</p><blockquote><p>Building with libstdc++ was deprecated with Xcode 8 and is not supported in Xcode 10 when targeting iOS. C++ projects must now migrate to libc++ and are recommended to set a deployment target of macOS 10.9 or later, or iOS 7 or later. Besides changing the C++ Standard Library build setting, developers should audit hard-coded linker flags and target dependencies to remove references to libstdc++ (including -lstdc++, -lstdc++.6.0.9, libstdc++.6.0.9.tbd, and libstdc++.6.0.9.dylib). Project dependencies such as static archives that were built against libstdc++ will also need to be rebuilt against libc++. (40885260)<br>所以苹果在 Xcode10 中移除了对 libstdc++ 的支持。</p></blockquote><p>2、具体的报错可能会有这些</p><ol><li>libray not found for -lstdc++.6.0.9</li><li>libray not found for -lstdc++</li><li>libray not found for libstdc++.6.0.9.tbd</li></ol><p>3、解决办法</p><ol><li>在Build Phases -&gt; Link Binary With Libraries 中删除<code>lstdc++</code>、<code>lstdc++.6.0.9</code>、<code>libstdc++.6.0.9.tbd</code>,并且添加<code>libc++</code>。</li><li>对于有使用 pod 的项目，在debug.xcconfig和release.xcconfig中也需要删除<code>lstdc++.6.0.9</code>、</li></ol><p>4、删除完了这些后还可能编译不成功的问题<br>我在做完这些操作后，我 clean 了项目，然后再次编译的时候，还是有报错，但是其实我已经把引用到这个库的地方都删掉了<br><img src="https://upload-images.jianshu.io/upload_images/2239937-848b52834ec3858b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我全局搜索了一下，在Build Settings 中找到了这个<br><img src="https://upload-images.jianshu.io/upload_images/2239937-ecece630e02378cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/2239937-7f8054d0ac0dd3ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/2239937-105ecf1dca3ceace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>接着就是在c++ standard Library 中选择 libc++ ，然后编译，成功解决了报错。</p><h1 id="升级后关于Xs-Max-和-XR的适配"><a href="#升级后关于Xs-Max-和-XR的适配" class="headerlink" title="升级后关于Xs Max 和 XR的适配"></a>升级后关于Xs Max 和 XR的适配</h1><p>花了一下午的时间升级了Xcode 10,接着就是关于iPhone Xs Max 和XR 的适配了</p><h2 id="启动页的分辨率"><a href="#启动页的分辨率" class="headerlink" title="启动页的分辨率"></a>启动页的分辨率</h2><h4 id="Xs-Max-1242-2688"><a href="#Xs-Max-1242-2688" class="headerlink" title="Xs Max: 1242 * 2688"></a>Xs Max: 1242 * 2688</h4><h4 id="XR-828-1792-png"><a href="#XR-828-1792-png" class="headerlink" title="XR: 828*1792.png"></a>XR: 828*1792.png</h4><h2 id="一些判断用的宏"><a href="#一些判断用的宏" class="headerlink" title="一些判断用的宏"></a>一些判断用的宏</h2><pre><code>#define isPad ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)#define iPhone5 ([UIScreen mainScreen].bounds.size.height == 568)#define iPhone4 ([UIScreen mainScreen].bounds.size.height == 480)#define iPhone6 ([UIScreen mainScreen].bounds.size.height == 667)#define iPhone6P ([UIScreen mainScreen].bounds.size.height == 736)#define iPhoneX ([UIScreen mainScreen].bounds.size.height == 812)#define iPhoneXR ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(828, 1792), [[UIScreen mainScreen] currentMode].size) &amp;&amp; !isPad : NO)#define iPhoneXsMax ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242, 2688), [[UIScreen mainScreen] currentMode].size)&amp;&amp; !isPad : NO)</code></pre><h1 id="脱坑"><a href="#脱坑" class="headerlink" title="脱坑"></a>脱坑</h1><p>终于完成了 Xcode 9 到 Xcode 10 的迁移，总的来说比之前可能稍微麻烦了一些。在此做个记录</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/f2a24732cf14" target="_blank" rel="noopener">xsmax 的宏</a><br><a href="https://www.jianshu.com/p/f8a3ccbfbd7b" target="_blank" rel="noopener">Xcode 10 升级项目报错</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;上周在打包上传后，报了一个警告，大致的意思就是这样的：&lt;code&gt;2019年3月必须使用Xcode 10.1或更高版本&lt;/code&gt;，此时的我还在用 Xcode 9，刚好最近刚上了包，就升级了Xcode 10&lt;br&gt;
    
    </summary>
    
      <category term="Xcode" scheme="http://LikeeCat.github.io/categories/Xcode/"/>
    
    
      <category term="Xcode" scheme="http://LikeeCat.github.io/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage 不能及时更新图片</title>
    <link href="http://LikeeCat.github.io/2018/12/03/SDWebImage%20%E4%B8%8D%E8%83%BD%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E5%9B%BE%E7%89%87/"/>
    <id>http://LikeeCat.github.io/2018/12/03/SDWebImage 不能及时更新图片/</id>
    <published>2018-12-03T10:05:13.000Z</published>
    <updated>2019-05-29T08:28:58.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近刚好有写到图片需要及时更新的问题，由于 SDWebImage 中的存在缓存，在用户更新了网络头像后，其他人的手机上还是显示了之前的头像，想到了缓存的问题<br><a id="more"></a></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>后来查到了这种解决方法，SDWebImageDownloader 有一个 headerFilter 属性</p><pre><code>/** * Set filter to pick headers for downloading image HTTP request. * * This block will be invoked for each downloading image request, returned * NSDictionary will be used as headers in corresponding HTTP request. */@property (nonatomic, copy, nullable) SDWebImageDownloaderHeadersFilterBlock headersFilter;</code></pre><p>划重点<code>Set filter to pick headers for downloading image HTTP request.</code>，所以我们可以在这里对下载图片的请求头进行一些处理。具体的代码如下：</p><pre><code>   SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;   imgDownloader.headersFilter  = ^NSDictionary *(NSURL *url, NSDictionary *headers) {    NSFileManager *fm = [[NSFileManager alloc] init];    NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];    NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];    NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil];    NSMutableDictionary *mutableHeaders = [headers mutableCopy];    NSDate *lastModifiedDate = nil;    if (fileAttr.count &gt; 0) {        if (fileAttr.count &gt; 0) {            lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate];        }    }    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];    formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;GMT&quot;];    formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];    formatter.dateFormat = @&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;;    NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];    lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @&quot;&quot;;    [mutableHeaders setValue:lastModifiedStr forKey:@&quot;If-Modified-Since&quot;];    return mutableHeaders;}</code></pre><h1 id="什么是-If-Modified-Since"><a href="#什么是-If-Modified-Since" class="headerlink" title="什么是 If-Modified-Since"></a>什么是 If-Modified-Since</h1><p><strong><code>If-Modified-Since</code></strong> 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" title="状态码 200 OK 表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。" target="_blank" rel="noopener"><code>200</code></a>  。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" title="HTTP 304 未改变说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since。" target="_blank" rel="noopener"><code>304</code></a>  响应，而在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" title="The Last-Modified  是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  ETag 要低，所以这是一个备用机制。包含有  If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段。" target="_blank" rel="noopener"><code>Last-Modified</code></a> 首部中会带有上次修改时间。 不同于  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since" title="HTTP协议中的 If-Unmodified-Since 消息头用于请求之中，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 POST 或其他 non-safe 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 412 (Precondition Failed) 错误。" target="_blank" rel="noopener"><code>If-Unmodified-Since</code></a>, <code>If-Modified-Since</code> 只可以用在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" title="HTTP GET 方法请求指定的资源。使用 GET 的请求应该只用于获取数据。" target="_blank" rel="noopener"><code>GET</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" title="HTTP HEAD 方法 请求资源的首部信息, 并且这些首部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源." target="_blank" rel="noopener"><code>HEAD</code></a> 请求中。</p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>所以我们在http 请求的 header 中 加入这个参数，拿到本地缓存图片的修改时间<code>NSFileModificationDate</code>。<br>200 -&gt; 更新图片(已更新)<br>304 -&gt; 使用之前的图片(未更新)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/3d5a99790760" target="_blank" rel="noopener">SDWebImage支持URL不变时更新图片内容</a><br><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN Web 文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;最近刚好有写到图片需要及时更新的问题，由于 SDWebImage 中的存在缓存，在用户更新了网络头像后，其他人的手机上还是显示了之前的头像，想到了缓存的问题&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://LikeeCat.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://LikeeCat.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 之 表单的自动填充</title>
    <link href="http://LikeeCat.github.io/2018/09/11/UITableView%20%E4%B9%8B%20%E8%A1%A8%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%20/"/>
    <id>http://LikeeCat.github.io/2018/09/11/UITableView 之 表单的自动填充 /</id>
    <published>2018-09-11T08:15:13.000Z</published>
    <updated>2019-05-29T04:37:35.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近在做一些复杂的表单提交界面，由于 TableView 的复用问题，有了很多的坑，在此做一些记录<br><a id="more"></a></p><h1 id="入坑前"><a href="#入坑前" class="headerlink" title="入坑前"></a>入坑前</h1><p>你的页面可能是这个样子的，很常规的，左边名称，右边输入相关的内容。然后你输入了相关的内容，上下滑动页面，然后再划回去。textField 可能清理掉了你输入的值<br><img src="https://upload-images.jianshu.io/upload_images/2239937-1750e1763419e818.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表单"></p><h2 id="摆出问题"><a href="#摆出问题" class="headerlink" title="摆出问题"></a>摆出问题</h2><ol><li>自动填充textField<br>你可能需要从某个 VC 或者网络接口请求数据，然后自动填充到相关的输入框中，你的 tableView 因为 cell 的复用，导致你修改了自动填充的内容，当你上下滑动表格的时候，它又恢复到了没有修改之前的值。那么你去提交表单的时候，你需要遍历这个表的每一个 textField,然后去取出相应的内容。接下来包成一个 JSON,传给后台</li></ol><h3 id="自动填充的一些想法"><a href="#自动填充的一些想法" class="headerlink" title="自动填充的一些想法"></a>自动填充的一些想法</h3><ol><li>自动填充 textField<br>界面加载完成后，传统的 MVC 中我们有个 model 来提供数据 。然后通知 UITableView 进行 <code>reloadData</code>,接着调用这个万恶的函数，恰恰就是这个函数让 cell 在复用的过程中，没能正确的显示自动填充的内容。<code>dequeueReusableCellWithIdentifier</code>这个万恶的单元格复用。</li></ol><pre><code>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{    TableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];        //do something}</code></pre><p>如果你不使用同一个identifier，那么 tableView 会注册更多的 identifier,可以避免这个问题，但是再次的创建 cell 是需要时间和空间的，如果你的输入框越来越多，难道还要创建越来越多的 cell 么</p><h3 id="自动填充的实现思路"><a href="#自动填充的实现思路" class="headerlink" title="自动填充的实现思路"></a>自动填充的实现思路</h3><p>我的想法是在 textField 输入和 textField 的显示中间，添加 model 作为数据的代理，具体的分为三个部分</p><ol><li>监听 textField 的输入，然后通知 model</li><li>更新 model</li><li>reloadData</li></ol><p>具体的分为 cell 和 vc 两个部分 ，</p><h4 id="cell-h"><a href="#cell-h" class="headerlink" title="cell.h"></a>cell.h</h4><pre><code>@class cellModel;typedef void(^reloadOperation)(void);@interface TableViewCell : UITableViewCell//更新cell 数据，并且在 field 的内容完成输入的时候，通知 VC- (void)updateWithModel:(cellModel *)model FinishLoad:(reloadOperation)reload;</code></pre><h4 id="cell-m"><a href="#cell-m" class="headerlink" title="cell.m"></a>cell.m</h4><pre><code>#import &quot;TableViewCell.h&quot;#import &quot;cellModel.h&quot;typedef void(^endEditing) (NSString *text);@interface TableViewCell ()&lt;UITextFieldDelegate&gt;@property (weak, nonatomic) IBOutlet UILabel *name;@property (weak, nonatomic) IBOutlet UITextField *field;@property (copy, nonatomic) endEditing endEditing;@end@implementation TableViewCell-(void)updateWithModel:(cellModel *)model FinishLoad:(reloadOperation)reload{    self.name.text = model.name;    self.field.text = model.url;    self.field.delegate = self;    self.endEditing = ^(NSString *text) {      //在输入结束的回调中，更新 model 的相关输入        model.url = text;      //通知 VC 需要进行数据的刷新了        reload();};}//在输入完成的时候，通知 cell 完成了 field 的输入-(void)textFieldDidEndEditing:(UITextField *)textField{    self.endEditing(textField.text);}</code></pre><h4 id="vc-m"><a href="#vc-m" class="headerlink" title="vc.m"></a>vc.m</h4><pre><code>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{    TableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];    cellModel *model = self.dataArray[indexPath.row];    [cell updateWithModel:model FinishLoad:^{        NSLog(@&quot;model.text is %@&quot;,model.url);        //回调 刷新数据        [tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationNone];    }];return cell;}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>tableView 作为一个 iOS 中最常用的控件，还是不希望大家在重用 cell 的时候创建那么多的 identifier。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;最近在做一些复杂的表单提交界面，由于 TableView 的复用问题，有了很多的坑，在此做一些记录&lt;br&gt;
    
    </summary>
    
      <category term="UITableView" scheme="http://LikeeCat.github.io/categories/UITableView/"/>
    
    
      <category term="UITableView" scheme="http://LikeeCat.github.io/tags/UITableView/"/>
    
  </entry>
  
</feed>
